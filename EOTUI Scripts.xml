<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>EOTUI</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>eotui = eotui or {}
eotui.version = eotui.version or .7
eotui.container = eotui.container or {}
--combine stats and inventory to one tabbed window
--combine field color info and mapper
eotui.settings =
  eotui.settings or
  {
    leftborderpercent = 0.20,
    rightborderpercent = 0.30,
    tabfontsize = 15,
    bodyfontsize = 10,
    chatfontsize = 10,
    invfontsize = 10,
    statsfontsize = 10,
    afffontsize = 10,
    gaugefontsize = 10,
    winbackcolor = "black",
    fonttype = "Courier New",
    settingsWindowOpen = false,
    combineStatsInv = false,
    combineFieldMap = false,
  }
eotui.settings.colors =
  eotui.settings.colors or
  {
    exp = "OrangeRed",
    emphasis = "light_goldenrod",
    divider = "white",
    header = "DeepSkyBlue",
    highhp = "DarkGreen",
    midhp = "yellow",
    lowhp = "red",
    highmp = "DarkGreen",
    midmp = "yellow",
    lowmp = "red",
    gold = "yellow",
    worn = "green",
    tab = "DimGray",
    guild = "cyan",
    build = "white",
    players = "cyan",
    legends = "yellow",
    hostiles = "red",
    innocents = "LightSkyBlue",
    peacefuls = "cyan",
    activetab = "DarkGreen",
    inactivetab = "bisque",
    inactivetoggle = "Black",
    activetoggle = "DimGrey",
    offborder = "white",
    onborder = "LimeGreen",
    lowcount = "DarkOrange",
    highcount = "cyan",
    defense = "green",
    affliction = "red",
  }
-- Vitals
eotui.vitals =
  eotui.vitals or
  {curhealth = 50, maxhealth = 100, curmana = 50, maxmana = 100, curmorph = 50, maxmorph = 100}
-- Gauge Variables
eotui.useGauges = eotui.useGauges or {enabled = enabled or true}
-- Defense Variable
eotui.defenses = eotui.defenses or {}
-- Enemy Variables
eotui.enemy = eotui.enemy or {curehealth = 50, maxhealth = 50}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Load Eot UI on Connect (eotui.initEOTUI)</name>
				<packageName></packageName>
				<script>-- This function here solely so you can do anything you would need
-- to do pre-gui generation as it calls the actual GUI creation at
-- the end

function eotui.initEOTUI()
  --auto makes you use full mode
  send("yes")
  -- begins loading EotUI
  eotui.settingsLoad()
  eotui.statsInvContainerSetup()
  eotui.fieldMapContainerSetup()
  --if eotui.settings.settingsWindowOpen == true then
  --  eotui.settingsContainer:show()
  --else
  --  eotui.settingsContainer:hide()
  --end
  info("Type 'eotui' to see a list of useful system help files.")
end

registerAnonymousEventHandler("sysConnectionEvent", "eotui.initEOTUI")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Setup Containers (eotui.setupContainers)</name>
				<packageName></packageName>
				<script>--These only setup the main containers and their names not whats inside them
--those are under the folder "UI Setup"

function eotui.setupContainers()
  --spot incase people want to center their UI
  --will add in later
  
  --field info
  eotui.fieldInfoContainer = eotui.fieldInfoContainer or Adjustable.Container:new({
    name = "eotui.fieldInfoContainer"})
  eotui.fieldInfoContainer:setTitle("Field Info")
    
  --mapper
  eotui.mapperContainer = eotui.mapperContainer or Adjustable.Container:new({
    name = "eotui.mapperContainer"})
  eotui.mapperContainer:setTitle("EoT Mapper")
  
  --inventory
  eotui.invHolder = eotui.invHolder or Adjustable.Container:new({
    name = "eotui.invHolder"})
  eotui.invHolder:setTitle("Inventory")
  
  --stats
  eotui.statsContainer = eotui.statsContainer or Adjustable.Container:new({
    name = "eotui.statsContainer"})
  eotui.statsContainer:setTitle("Stats")
    
  --affect info
  eotui.affInfoContainer = eotui.affInfoContainer or Adjustable.Container:new({
    name = "eotui.affInfoContainer"})
  eotui.affInfoContainer:setTitle("Aff Info")
  
  --hp bar
  eotui.vitals.hp = eotui.vitals.hp or Adjustable.Container:new({
    name = "eotui.vitals.hp"})
  eotui.vitals.hp:setTitle("HP")
  
  --mana bar
  eotui.vitals.mp = eotui.vitals.mp or Adjustable.Container:new({
    name = "eotui.vitals.mp"})
  eotui.vitals.mp:setTitle("Mana")

  --enemy bar
  eotui.enemybar = eotui.enemybar or Adjustable.Container:new({
		name = "eotui.enemybar"})
  eotui.enemybar:setTitle("Enemy")
  
  --chat system holder
  eotui.chatbox = eotui.chatbox or Adjustable.Container:new({
    name = "eotui.chatbox"})
  eotui.chatbox:setTitle("Chat")
  
  --settings
  eotui.settingsContainer = eotui.settingsContainer or Adjustable.Container:new({
    name = "eotui.settingsContainer"})
  eotui.settingsContainer:setTitle("Settings")
  eotui.settingsContainer:hide()
  
  --Combined Stats and Inv Box
  eotui.statsInvCombined = eotui.statsInvCombined or Adjustable.Container:new({
    name = "eotui.statsInvCombined"})
  eotui.statsInvCombined:setTitle("Stats and Inventory")
  eotui.statsInvCombined:hide()
  
  --Combined Field and Mapper Box
  eotui.fieldMapCombined = eotui.fieldMapCombined or Adjustable.Container:new({
    name = "eotui.fieldMapCombined"})
  eotui.fieldMapCombined:setTitle("Field and Maps")
  eotui.fieldMapCombined:hide()
  
  --Morph Meter
  eotui.morphContainer = eotui.morphContainer or Adjustable.Container:new({
    name = "eotui.morphContainer"})
  eotui.morphContainer:setTitle("Morph Gauge")
  eotui.morphContainer:hide()
  
  --Group
  eotui.groupContainer = eotui.groupContainer or Adjustable.Container:new({
    name = "eotui.groupContainer"})
  eotui.groupContainer:setTitle("Group Tracker")
  eotui.groupContainer:hide()
  
  raiseEvent("containers_created") --send out we are done making the containers
  --used to trigger the other stuff to finish creating everything and start populating
  --them
end
  
  
 </script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Group Tracker</name>
				<packageName></packageName>
				<script>--Group Tracker
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Setup Group Tracker (eotui.setupGroupTracker)</name>
					<packageName></packageName>
					<script>function eotui.setupGroupTracker()
  eotui.groupTracker = eotui.groupTracker or Geyser.MiniConsole:new({
		  name = "eotui.groupTracker",}, eotui.groupContainer) -- 
	eotui.groupTracker:move(0, 0)
	eotui.groupTracker:resize("-0", "100%")
	setMiniConsoleFontSize("eotui.groupTracker", 10);
  eotui.groupTracker:setColor(eotui.settings.winbackcolor)
end

registerAnonymousEventHandler("containers_created", "eotui.setupGroupTracker")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Group Info Pull (eotui.pullGroupInfo)</name>
					<packageName></packageName>
					<script>--Idea:
--modify to display other options if you are a healer
--one click heal casting ect...


function eotui.pullGroupInfo()
	local tg = TextGauge:new()
	local max_group_size 	= #msdp.GROUP
	local group_size 			= 1
	
	clearWindow("eotui.groupTracker")
	
	if #msdp.GROUP &gt;= 1 then
		while (group_size &lt;= max_group_size) do
			if msdp.GROUP[group_size].NAME ~= nil then
				if msdp.GROUP[group_size].CUR_HP ~= msdp.GROUP[group_size].MAX_HP then 
					local bar_change = ((tonumber(msdp.GROUP[group_size].CUR_HP) / tonumber(msdp.GROUP[group_size].MAX_HP)) * 100)
					cecho ("eotui.groupTracker", ""..tostring(msdp.GROUP[group_size].NAME) .. "  Hp: "..tonumber(msdp.GROUP[group_size].CUR_HP).." / "..tonumber(msdp.GROUP[group_size].MAX_HP).."\n")
					cecho("eotui.groupTracker", tg:setValue(bar_change) .. "\n")
				else
					cecho ("eotui.groupTracker", ""..tostring(msdp.GROUP[group_size].NAME) .. "  Hp: "..tonumber(msdp.GROUP[group_size].CUR_HP).." / "..tonumber(msdp.GROUP[group_size].MAX_HP).."\n")
					cecho("eotui.groupTracker", tg:setValue(100) .. "\n")
				end
				group_size = group_size+1    
    	end
  	end
	end
end

registerAnonymousEventHandler("msdp.GROUP", "eotui.pullGroupInfo")</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Utilities</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Demonic Text Gauges</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>text gauges</name>
						<packageName></packageName>
						<script>---TextGauges
-- Creates a text based gauge, for use in miniconsoles and the like.
--@module TextGauge
TextGauge = {
  width = 24,
  fillCharacter = ":",
  emptyCharacter = "-",
  showPercent = true,
  showPercentSymbol = true,
  format = "c",
  value = 50,
}

--- Sets the width in characters of the gauge
--@tparam number width number of characters wide to make the gauge
function TextGauge:setWidth(width)
  local widthType = type(width)
  assert(widthType == "number", string.format("TextGauge:setWidth(width): width as number expected, got %s", widthType))
  self.width = width
end

function TextGauge:setFormat(format)
  self.format = self:getColorType(format)
  self:setDefaultColors()
end

--- Sets the character to use for the 'full' part of the gauge
--@tparam string character the character to use. 
function TextGauge:setFillCharacter(character)
  assert(character ~= nil, "TextGauge:setFillCharacter(character): character required, got nil")
  assert(utf8.len(character) == 1, "TextGauge:setFillCharacter(character): character must be a single character")
  self.fillCharacter = character
end

--- Sets the character to use for the 'full' part of the gauge
--@tparam string character the character to use. 
function TextGauge:setEmptyCharacter(character)
  assert(character ~= nil, "TextGauge:setEmptyCharacter(character): character required, got nil")
  assert(utf8.len(character) == 1, "TextGauge:setEmptyCharacter(character): character must be a single character")
  self.emptyCharacter = character
end

--- Sets the fill color for the gauge.
--@tparam string color the color to use for the full portion of the gauge. Will be run through Geyser.Golor
function TextGauge:setFillColor(color)
  assert(color ~= nil, "TextGauge:setFillColor(color): color required, got nil")
  self.fillColor = color
end

--- Sets the empty color for the gauge.
--@tparam string color the color to use for the empty portion of the gauge. Will be run through Geyser.Golor
function TextGauge:setEmptyColor(color)
  assert(color ~= nil, "TextGauge:setEmptyColor(color): color required, got nil")
  self.emptyColor = color
end

--- Sets the fill color for the gauge.
--@tparam string color the color to use for the numeric value. Will be run through Geyser.Golor
function TextGauge:setPercentColor(color)
  assert(color ~= nil, "TextGauge:setPercentColor(color): color required, got nil")
  self.percentColor = color
end
--- Sets the fill color for the gauge.
--@tparam string color the color to use for the numeric value. Will be run through Geyser.Golor
function TextGauge:setPercentSymbolColor(color)
  assert(color ~= nil, "TextGauge:setPercentSymbolColor(color): color required, got nil")
  self.percentSymbolColor = color
end

--- Enables showing the percent value of the gauge
function TextGauge:enableShowPercent()
  self.showPercent = true
end

--- Disables showing the percent value of the gauge
function TextGauge:disableShowPercent()
  self.showPercent = false
end

--- Enables showing the percent symbol (appears after the value)
function TextGauge:enableShowPercentSymbol()
  self.showPercentSymbol = true
end

--- Enables showing the percent symbol (appears after the value)
function TextGauge:disableShowPercentSymbol()
  self.showPercentSymbol = false
end

function TextGauge:getColorType(format)
  format = format or self.format
  local dec = {"d", "decimal", "dec", "decho"}
  local hex = {"h", "hexidecimal", "hex", "hecho"}
  local col = {"c", "color", "colour", "col", "name", "cecho"}
  if table.contains(col, format) then
    return "c"
  elseif table.contains(dec, format) then
    return "d"
  elseif table.contains(hex, format) then
    return "h"
  else
    return ""
  end
end

-- internal function, used at instantiation to ensure some colors are set
function TextGauge:setDefaultColors()
  local colorType = self:getColorType()
  if colorType == "c" then
    self.percentColor = self.percentColor or "white"
    self.percentSymbolColor = self.percentSymbolColor or self.percentColor
    self.fillColor = self.fillColor or "DarkOrange"
    self.emptyColor = self.emptyColor or "white"
    self.resetColor = "&lt;reset&gt;"
  elseif colorType == "d" then
    self.percentColor = self.percentColor or "&lt;255,255,255&gt;"
    self.percentSymbolColor = self.percentSymbolColor or self.percentColor
    self.fillColor = self.fillColor or "&lt;255,140,0&gt;"
    self.emptyColor = self.emptyColor or "&lt;255,255,255&gt;"
    self.resetColor = "&lt;r&gt;"
  elseif colorType == "h" then
    self.percentColor = self.percentColor or "#ffffff"
    self.percentSymbolColor = self.percentSymbolColor or self.percentColor
    self.fillColor = self.fillColor or "#ff8c00"
    self.emptyColor = self.emptyColor or "#ffffff"
    self.resetColor = "#r"
  else
    self.percentColor = self.percentColor or ""
    self.percentSymbolColor = self.percentSymbolColor or self.percentColor
    self.fillColor = self.fillColor or ""
    self.emptyColor = self.emptyColor or ""
    self.resetColor = ""
  end
end

-- Internal function used to route Geyser.Color based on internally stored format
function TextGauge:getColor(color)
  local colorType = self:getColorType()
  if colorType == "c" then
    return string.format("&lt;%s&gt;",color) -- pass the color back in &lt;&gt; for cecho
  elseif colorType == "d" then
    return Geyser.Color.hdec(color) -- return it in decho format
  elseif colorType == "h" then
    return Geyser.Color.hex(color) -- return it in hex format
  else
    return "" -- return an empty string for noncolored output
  end
end

--- Used to set the gauge's value and return the string representation of the gauge
--@tparam[opt] number current current value. If no value is passed it will use the stored value. Defaults to 50 to prevent errors.
--@tparam[opt] number max maximum value. If not passed, the internally stored one will be used. Defaults to 100 so that it can be used with single values as a percent
--@usage myGauge:setValue(55) -- sets the gauge to 55% full
--@usage myGauge:setValue(2345, 2780) -- will figure out what the percentage fill is based on the given current/max values
function TextGauge:setValue(current,max)
  current = current or self.value
  assert(type(current) == "number", "TextGauge:setValue(current,max) current as number expected, got " .. type(current))
  assert(max == nil or type(max) == "number", "TextGauge:setValue(current, max) option max as number expected, got " .. type(max))
  if current &lt; 0 then current = 0 end
  max = max or 100
  local value = math.floor(current / max * 100)
  if value &gt; 100 then value = 100 end
  self.value = value
  local width = self.width
  local percentString = ""
  local percentSymbolString = ""
  local fillCharacter = self.fillCharacter
  local emptyCharacter = self.emptyCharacter
  local fillColor = self:getColor(self.fillColor)
  local emptyColor = self:getColor(self.emptyColor)
  local percentColor = self:getColor(self.percentColor)
  local percentSymbolColor = self:getColor(self.percentSymbolColor)
  local resetColor = self.resetColor
  if self.showPercent then 
    percentString = string.format("%s%02d%s", percentColor, value, resetColor)
    width = width - 2
  end
  if self.showPercentSymbol then
    percentSymbolString = string.format("%s%s%s", percentSymbolColor, "%", resetColor)
    width = width - 1
  end
  local perc = (current / max)
  local fillWidth = math.floor(perc * width)
  local emptyWidth = width - fillWidth
  if value == 100 then fillWidth = fillWidth -1 end
  return string.format("%s%s%s%s%s%s%s%s%s", fillColor, string.rep(fillCharacter, fillWidth),resetColor, emptyColor, string.rep(emptyCharacter, emptyWidth), resetColor, percentString, percentSymbolString, resetColor)
end

--- Synonym for setValue
function TextGauge:print(...)
  self:setValue(...)
end

--- Creates a new TextGauge.
-- Please see the wiki for more information on valid options.
--@tparam[opt] table options The table of options you would like the TextGauge to start with.
function TextGauge:new(options)
  options = options or {}
  local optionsType = type(options)
  assert(optionsType == "table" or optionsType == "nil", "TextGauge:new(options): options expected as table, got " .. optionsType )
  
  local me = table.deepcopy(options)
  setmetatable(me, self)
  self.__index = self
  me:setDefaultColors()
  return me
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Colors</name>
					<packageName></packageName>
					<script>-- Color schemes for the UI.</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>color table additions</name>
						<packageName></packageName>
						<script>color_table["a_darkred"]           = {128, 0, 0}
color_table["a_darkgreen"]         = {0, 179, 0}
color_table["a_brown"]             = {128, 128, 0}
color_table["a_darkblue"]          = {0, 0, 128}
color_table["a_darkmagenta"]       = {128, 0, 128}
color_table["a_darkcyan"]          = {0, 128, 128}
color_table["a_grey"]              = {192, 192, 192}
color_table["a_darkgrey"]          = {128, 128, 128}
color_table["a_red"]               = {255, 0, 0}
color_table["a_green"]             = {0, 255, 0}
color_table["a_yellow"]            = {255, 255, 0}
color_table["a_blue"]              = {0, 85, 255}
color_table["a_magenta"]           = {255, 0, 255}
color_table["a_cyan"]              = {0, 255, 255}
color_table["a_white"]             = {255, 255, 255}</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>fText</name>
					<packageName></packageName>
					<script>-- fText, the text formatting library. By Demonnic.
-- https://forums.mudlet.org/viewtopic.php?f=6&amp;t=22763</script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>TextFormatter</name>
						<packageName></packageName>
						<script></script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>standaloneFormatter</name>
							<packageName></packageName>
							<script>demonnic = demonnic or {}
demonnic.text = {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)  
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then 
    error("Improper argument: options expected to be passed as table") 
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
	options.rightCap = options.cap
  options.leftPadLen = math.floor((options.width - options.strLen)/2,1) - 1
  options.rightPadLen = options.leftPadLen + ((options.width - options.strLen)%2)
  options.maxPad = 0
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then 
      gapSpaces = 2 
    else 
      gapSpaces = 1 
    end
  end
  options.effWidth = options.width - ((options.capLen * 2) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local strippedString = options.strippedString
  local strLen = options.strLen
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local maxPad = options.maxPad
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end
    
  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end
    
  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. 
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then 
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne" 
  -- "endcap================= some text" 
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else 
  --"=====endcap some text endcap=====" 
  --"=====endcap some text pacdne====="
  --"=================endcap some text" 
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."
  
  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"
  
  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"
  
  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>reusableFormatter</name>
							<packageName></packageName>
							<script>demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}


function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>tableFormatter</name>
							<packageName></packageName>
							<script>demonnic = demonnic or {}
demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",

  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  if type(entry) ~= "string" then
    if type(entry) == "function" then
      local entryReturn = entry()
      if type(entryReturn) ~= string and not tostring(entryReturn) then entry = 0 end
    elseif not tostring(entry) then
      entry = 0
    end
  end
  return entry
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

function demonnic.TableMaker:assemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  return sheet
end


function demonnic.TableMaker:new(options)
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Settings Save &amp; Load</name>
					<packageName></packageName>
					<script>-- Lets the user save settings, lets the system remember them.

function eotui.settingsSave()
  local settings_table = {useGauges = {enabled = ""}}
  local filename = "eotui.settings.lua"
  local defsave = "eotui.defenses.lua"
  
  -- Save Current Version
  settings_table.current_version = eotui.version
  
  -- Save Misc. Settings  
  settings_table.combineFieldMap = eotui.settings.combineFieldMap
  settings_table.combineStatsInv = eotui.settings.combineStatsInv
  settings_table.groupTrackerOpen = eotui.settings.groupTrackerOpen
  settings_table.loggedOn = eotui.settings.loggedOn
  
  -- Save general user settings
  settings_table.rightborderpercent = eotui.settings.rightborderpercent
  settings_table.leftborderpercent = eotui.settings.leftborderpercent
  settings_table.winbackcolor = eotui.settings.winbackcolor
  settings_table.settingsWindowOpen = eotui.settings.settingsWindowOpen
  settings_table.combineStatsInv = eotui.settings.combineStatsInv
  settings_table.combineFieldMap = eotui.settings.combineFieldMap
  
  
  -- Save colors
  settings_table.exp = eotui.settings.colors.exp
  settings_table.emphasis = eotui.settings.colors.emphasis
  settings_table.divider = eotui.settings.colors.divider
  settings_table.header = eotui.settings.colors.header
  settings_table.gold = eotui.settings.colors.gold
  settings_table.guild = eotui.settings.colors.guild
  settings_table.tab = eotui.settings.colors.tab
  settings_table.activetab = eotui.settings.colors.activetab
  settings_table.inactivetab = eotui.settings.colors.inactivetab
  settings_table.activetoggle = eotui.settings.colors.activetoggle
  settings_table.inactivetoggle = eotui.settings.colors.inactivetoggle
  settings_table.onborder = eotui.settings.colors.onborder
  settings_table.offborder = eotui.settings.colors.offborder
  settings_table.lowcount = eotui.settings.colors.lowcount
  settings_table.highcount = eotui.settings.colors.highcount
  settings_table.defense = eotui.settings.colors.defense
  settings_table.affliction = eotui.settings.colors.affliction
  settings_table.buildcolor = eotui.settings.colors.build
  settings_table.worn = eotui.settings.colors.worn
  settings_table.players = eotui.settings.colors.players
  settings_table.legends = eotui.settings.colors.legends
  settings_table.peacefuls = eotui.settings.colors.peacefuls
  settings_table.innocents = eotui.settings.colors.innocents
  settings_table.hostiles = eotui.settings.colors.hostiles
  settings_table.highhp = eotui.settings.colors.highhp
  settings_table.midhp = eotui.settings.colors.midhp
  settings_table.lowhp = eotui.settings.colors.lowhp
  settings_table.highmp = eotui.settings.colors.highmp
  settings_table.midmp = eotui.settings.colors.midmp
  settings_table.lowmp = eotui.settings.colors.lowmp
  
  -- Save toggle settings
  settings_table.useGauges.enabled = eotui.useGauges.enabled
  
  -- Save font type and sizes
  settings_table.fonttype = eotui.settings.fonttype
  settings_table.tabfontsize = eotui.settings.tabfontsize
  settings_table.bodyfontsize = eotui.settings.bodyfontsize
  settings_table.chatfontsize = eotui.settings.chatfontsize
  settings_table.invfontsize = eotui.settings.invfontsize
  settings_table.statsfontsize = eotui.settings.statsfontsize
  settings_table.afffontsize = eotui.settings.afffontsize
  settings_table.gaugefontsize = eotui.settings.gaugefontsize
  
  table.save(eotui.os(filename), settings_table)
  table.save(eotui.os(defsave), eotui.defenses)
  info(string.format("User Specific Settings Saved To: '%s'", eotui.os(filename)))
  info(string.format("Defense Table Saved To: '%s'", eotui.os(defsave)))
  Adjustable.Container.saveAll()
  info("Container Locations Saved")
end

-- function
registerAnonymousEventHandler("sysExitEvent", "eotui.settingsSave")

function eotui.settingsLoad()
  local settings_table = {}
  local filename = "eotui.settings.lua"
  local defsave = "eotui.defenses.lua"
  if io.exists(eotui.os(filename)) then
    table.load(eotui.os(filename), settings_table)
    
    -- Load current version
    eotui.version = settings_table.current_version
    
    -- Save Misc. Settings
    eotui.settings.combineFieldMap = settings_table.combineFieldMap
    eotui.settings.combineStatsInv = settings_table.combineStatsInv
    eotui.settings.groupTrackerOpen = settings_table.groupTrackerOpen
    eotui.settings.loggedON = settings_table.loggedOn
  
    -- Load general user settings
    eotui.settings.rightborderpercent = settings_table.rightborderpercent
    eotui.settings.leftborderpercent = settings_table.leftborderpercent
    eotui.settings.winbackcolor = settings_table.winbackcolor or eotui.settings.winbackcolor
    eotui.settings.settingsWindowOpen = settings_table.settingsWindowOpen or eotui.settings.settingsWindowOpen
    eotui.settings.combineStatsInv = settings_table.combineStatsInv or false
    eotui.settings.combineFieldMap = settings_table.combineFieldMap or false
    -- Load colors
    eotui.settings.colors.exp = settings_table.exp
    eotui.settings.colors.emphasis = settings_table.emphasis
    eotui.settings.colors.divider = settings_table.divider
    eotui.settings.colors.header = settings_table.header
    eotui.settings.colors.gold = settings_table.gold
    eotui.settings.colors.guild = settings_table.guild
    eotui.settings.colors.tab = settings_table.tab
    eotui.settings.colors.activetab = settings_table.activetab
    eotui.settings.colors.inactivetab = settings_table.inactivetab
    eotui.settings.colors.activetoggle = settings_table.activetoggle
    eotui.settings.colors.inactivetoggle = settings_table.inactivetoggle
    eotui.settings.colors.onborder = settings_table.onborder
    eotui.settings.colors.offborder = settings_table.offborder
    eotui.settings.colors.lowcount = settings_table.lowcount
    eotui.settings.colors.highcount = settings_table.highcount
    eotui.settings.colors.defense = settings_table.defense
    eotui.settings.colors.affliction = settings_table.affliction
    eotui.settings.colors.build = settings_table.buildcolor
    eotui.settings.colors.worn = settings_table.worn
    eotui.settings.colors.players = settings_table.players
    eotui.settings.colors.legends = settings_table.legends
    eotui.settings.colors.peacefuls = settings_table.peacefuls
    eotui.settings.colors.innocents = settings_table.innocents
    eotui.settings.colors.hostiles = settings_table.hostiles
    eotui.settings.colors.highhp = settings_table.highhp
    eotui.settings.colors.midhp = settings_table.midhp
    eotui.settings.colors.lowhp = settings_table.lowhp
    eotui.settings.colors.highmp = settings_table.highmp
    eotui.settings.colors.midmp = settings_table.midmp
    eotui.settings.colors.lowmp = settings_table.lowmp
    
    -- Load toggle settings
    eotui.useGauges.enabled = settings_table.useGauges.enabled
    
    -- Load font types and sizes
    eotui.settings.fonttype = settings_table.fonttype or eotui.settings.fonttype
    eotui.settings.tabfontsize = settings_table.tabfontsize or eotui.settings.tabfontsize
    eotui.settings.bodyfontsize = settings_table.bodyfontsize or eotui.settings.bodyfontsize
    eotui.settings.chatfontsize = settings_table.chatfontsize or eotui.settings.chatfontsize
    eotui.settings.invfontsize = settings_table.invfontsize or eotui.settings.invfontsize
    eotui.settings.statsfontsize = settings_table.statsfontsize or eotui.settings.statsfontsize
    eotui.settings.afffontsize = settings_table.afffontsize or eotui.settings.afffontsize
    eotui.settings.gaugefontsize = settings_table.gaugefontsize or eotui.settings.gaugefontsize
  end
  -- if
  if io.exists(eotui.os(defsave)) then
    table.load(eotui.os(defsave), eotui.defenses)
  end
  info("User settings and defense table loaded.")
  -- all our settings are.. set, draw the outline of our ui.
  eotui.setupContainers()
  Adjustable.Container:loadAll() --load the containers
  
end

-- function
registerAnonymousEventHandler("sysLoadEvent", "eotui.settingsLoad")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Save File Location</name>
					<packageName></packageName>
					<script>-- Tells the system where our settings save file is.
function eotui.os(filename)
  if string.char(getMudletHomeDir():byte()) == "/" then
    _sep = "/"
  else
    _sep = "\\"
  end
	if not lfs.attributes(getMudletHomeDir() .. _sep .. "eotui") then
		lfs.mkdir(getMudletHomeDir() .. _sep .. "eotui")
	end
  local filename = getMudletHomeDir() .. _sep .. "eotui" .. _sep .. filename
	return filename
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Echoes</name>
					<packageName></packageName>
					<script>-- Echoes so we can shorthand prettify things.

function header(title, extra)
	local replen = 48 - (13 + title:len())
	cecho("&lt;DeepSkyBlue&gt;+&lt;a_blue&gt;----- &lt;DeepSkyBlue&gt;[&lt;snow&gt; " .. title:title() .. " &lt;DeepSkyBlue&gt;] " .. string.rep("&lt;a_blue&gt;-", replen) .. " &lt;DeepSkyBlue&gt;[&lt;spring_green&gt; ASUI For Asteria &lt;DeepSkyBlue&gt;] &lt;a_blue&gt;-----&lt;DeepSkyBlue&gt;+\n\n")
end

function footer()
	cecho("\n&lt;DeepSkyBlue&gt;+&lt;a_blue&gt;" .. string.rep("-", 51) .. "&lt;DeepSkyBlue&gt; [&lt;snow&gt; Version "..asui.version.." &lt;DeepSkyBlue&gt;]&lt;a_blue&gt; " .. string.rep("-", 5) .. "&lt;DeepSkyBlue&gt;+\n")
end

function info(args)
   cecho(string.format("%s", "&lt;lime_green&gt;[&lt;DarkTurquoise&gt;EOTUI&lt;lime_green&gt;]&lt;light_grey&gt;: &lt;snow&gt;") .. args:title() .. "\n")
end

function error(args)
	cecho(string.format("%s", "&lt;lime_green&gt;[&lt;DarkTurquoise&gt;EOTUI&lt;lime_green&gt;]&lt;light_grey&gt;: &lt;firebrick&gt;ERROR: &lt;red&gt;") .. args:title() .. "\n")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Force MSDP reload (eotui.forceMsdpReload)</name>
					<packageName></packageName>
					<script>--called whenever needed, forces EoT to resend relevant MSDP data
--does not force any channel related so its not double reported

function eotui.forceMsdpReload()

sendMSDP("REPORT", "CHARACTER_NAME", "AFFECTS", "ALIGNMENT", "EXPERIENCE", "EXPERIENCE_MAX", "EXPERIENCE_TNL", "HEALTH", "HEALTH_MAX")
sendMSDP("REPORT", "LEVEL", "RACE", "CLASS", "MANA", "MANA_MAX", "WIMPY", "AP", "GIL", "ACCURACY", "ATTACK", "DEFENSE", "MDEFENSE")
sendMSDP("REPORT", "PWR", "WIL", "AGI", "VIT", "PWR_PERM", "WIL_PERM", "AGI_PERM", "VIT_PERM")
sendMSDP("REPORT", "OPPONENT_HEALTH", "OPPONENT_HEALTH_MAX", "OPPONENT_LEVEL", "OPPONENT_NAME")

-- Area Data
sendMSDP("REPORT", "AREA_NAME", "ROOM_EXITS", "ROOM_NAME", "ROOM_VNUM", "PREV_DIR")

sendMSDP("REPORT", "LIMIT_MODE", "LIMIT_LEVEL", "LIMIT_METER", "SPELL_NAME", "SPELL_LEVEL", "SPELL_COST")
sendMSDP("REPORT", "SPELL_TIME", "SPELL_FAIL")
sendMSDP("REPORT", "SPEED", "CASTLVL", "CASTCAP", "THROTTLE", "EVADE", "CRIT_RATE", "CRIT_POWER", "MOBILITY", "CASTTIME")
sendMSDP("REPORT", "SAVES", "MIT_PARRY", "MIT_BLOCK", "BANK")
sendMSDP("REPORT", "ITEM_WEIGHT_CUR", "ITEM_WEIGHT_MAX", "ITEM_HELD_CUR", "ITEM_HELD_MAX")
sendMSDP("REPORT", "ELEM1", "ELEM2", "SECTOR", "COORDS_X", "COORDS_Y", "COORDS_MAP")
sendMSDP("REPORT", "WAIT", "DAZE", "MORPH")
sendMSDP("REPORT", "SKILL_CDS", "TECH_CDS")

-- 	Field data
--	they are reverse what they appear on the screen so order is actually:
--  4 3 2 1 0
sendMSDP("REPORT", "FIELD0", "FIELD1", "FIELD2", "FIELD3", "FIELD4", "LOCKED")

sendMSDP("REPORT" , "GROUP")
sendMSDP("REPORT" , "INVENTORY")
sendMSDP("REPORT" , "WORLD_TIME")


end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Cleanup Room_exits (eotui.cleanUpMsdpExits)</name>
					<packageName></packageName>
					<script>-- pulls in msdp.ROOM_EXITS data and removes the END from the vnums

function eotui.cleanUpMsdpExits()
  if table.contains(msdp.ROOM_EXITS, "north") then
    if tostring(msdp.ROOM_EXITS.north) ~= "" then
      local stripped = string.sub(tostring(msdp.ROOM_EXITS.north), 0, -4)
      msdp.ROOM_EXITS.north = tostring(stripped)
      info("north fired")
    end
  end 
  if table.contains(msdp.ROOM_EXITS, "east") then 
    if tostring(msdp.ROOM_EXITS.east) ~= "" then
      local stripped = string.sub(tostring(msdp.ROOM_EXITS.east), 0, -4)
      msdp.ROOM_EXITS.east = tostring(stripped)
      info("east fired")
    end
  end
  if table.contains(msdp.ROOM_EXITS, "south") then 
    if tostring(msdp.ROOM_EXITS.south) ~= "" then
      local stripped = string.sub(tostring(msdp.ROOM_EXITS.south), 0, -4)
      msdp.ROOM_EXITS.south = tostring(stripped)
      info("south fired")
    end
  end
  if table.contains(msdp.ROOM_EXITS, "west") then
    if tostring(msdp.ROOM_EXITS.west) ~= "" then
      local stripped = string.sub(tostring(msdp.ROOM_EXITS.west), 0, -4)
      msdp.ROOM_EXITS.west = tostring(stripped)
      info("west fired")
    end
  end
end

--registerAnonymousEventHandler("msdp.ROOM_EXITS", "eotui.cleanUpMsdpExits")</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>EMCO</name>
				<packageName></packageName>
				<script>-- By Demonnic</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>EMCO</name>
					<packageName></packageName>
					<script>--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
-- @module EMCO
EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
})

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _,channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.activeColors.r, config.activeColors.g, config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g, config.inactiveColors.b)
  constraints = string.format("%s  consoleColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Make a new script, then copy and paste the following output into it.
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then self.ae(funcName, "position as number expected, got " .. position) end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then self.ae(funcName, tabCheck) end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  if oldTab ~= tabName and oldTab ~= "" then
    self.windows[oldTab]:hide()
    self.tabs[oldTab]:setStyleSheet(self.inactiveTabCSS)
    self.tabs[oldTab]:setColor(self.inactiveTabBGColor)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor, "c")
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self.tabs[tabName]:setStyleSheet(self.activeTabCSS)
  self.tabs[tabName]:setColor(self.activeTabBGColor)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor, "c")
  if oldTab and self.windows[oldTab] then
    self.windows[oldTab]:hide()
  end
  self.windows[tabName]:show()
  self.currentTab = tabName
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({
    name = string.format("%sTab%s", self.name, tabName)
  }, self.tabBox)
  tab:echo(tabName, self.inactiveTabFGColor, 'c')
  -- use the inactive CSS. It's "" if unset, which is ugly, but
  tab:setStyleSheet(self.inactiveTabCSS)
  -- set the BGColor if set. if the CSS is set it overrides the setColor, but if it's "" then the setColor actually covers that.
  -- and we set a default for the inactiveBGColor
  tab:setColor(self.inactiveTabBGColor)
  tab:setClickCallback("EMCOHelper.switchTab", nil, string.format("%s+%s",self.name, tabName))
  self.tabs[tabName] = tab
  local window
  local windowConstraints = {
    x = 1,
    y = 1,
    height = "-2px",
    width = "100%",
    name = string.format("%sWindow%s", self.name, tabName)
  }
  local parent = self.consoleContainer
  if self.mapTab and tabName == self.mapTabName then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    window = Geyser.MiniConsole:new(windowConstraints, parent)
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
  end
  self.windows[tabName] = window
  window:hide()
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _,tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end
  local default
  if self.currentTab == "" then
    default = self.allTabName or self.consoles[1]
  else
    default = self.currentTab
  end
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x=0,
    y=0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel"
  }, self)
  self.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "100%",
    name = self.name .. "TabBox"
  }, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer"
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[hHmMszZaApPdy:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName, "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- &lt;br&gt;This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then self.ae(funcName, "allTabName expected as string, got" .. allTabNameType) end
  if not table.contains(self.consoles, allTabName) then self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.containers, ",")) end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName .. ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- &lt;br&gt;Forces a redraw of the object
-- &lt;br&gt;CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got ".. type(blinkeTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function() self:blink() end, true)
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab,_ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _,tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.windows[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _,console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    local tab = self.tabs[console]
    if console == self.currentTab then
      tab:setStyleSheet(self.activeTabCSS)
      tab:setColor(self.activeBGColor)
    else
      tab:setStyleSheet(self.inactiveTabCSS)
      tab:setColor(self.inactiveBGColor)
    end
  end
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.windows[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
    self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
    self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got ".. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _,console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.windows[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.windows[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- &lt;br&gt;it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _,console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.windows[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- &lt;br&gt;depending on this object's configuration, may gag the line
-- &lt;br&gt;depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got ".. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.windows[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.windows[self.allTabName] or false
  local ofr,ofg,ofb,obr,obg,obb
  if xtype == "a" then
    selectCurrentLine()
    ofr,ofg,ofb = getFgColor()
    obr,obg,obb = getBgColor()
    if self.preserveBackground then
      local r,g,b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r,g,b)
    end
    copy()
  else
    ofr,ofg,ofb = Geyser.Color.parse("white")
    obr,obg,obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab and tabName ~= self.allTabName then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function() deleteLine() end, 1)
      end
    end
  else
    console[xtype](console, message)
    if allTab then allTab[xtype](allTab, message) end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then allTab:echo("\n") end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local console = self.windows[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.windows[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      local ofr,ofg,ofb = Geyser.Color.parse("white")
      local obr,obg,obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then allTab[linkType](allTab, unpack(arguments)) end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  if not table.contains(self.allTabExclusions, tabName) then table.insert(self.allTabExclusions, tabName) end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then table.remove(self.allTabExclusions, index) end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.windows[console]:enableScrollBar()
      else
        self.windows[console]:disableScrollBar()
      end
    end
  end
end

EMCOHelper = EMCOHelper or {}
EMCOHelper.items = EMCOHelper.items or {}
function EMCOHelper:switchTab(designator)
  local args = string.split(designator, "+")
  local emcoName = args[1]
  local tabName = args[2]
  for _,emco in ipairs(EMCOHelper.items) do
    if emco.name == emcoName then
      emco:switchTab(tabName)
      return
    end
  end
end

EMCO.parent = Geyser.Container

--- Creates a new Embeddable Multi Console Object.
-- &lt;br&gt;see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or { "All" }
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" and string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] .. table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then self:se(funcName, "allTabExclusions must be a table if it is provided") end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag)then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.blinkTime = cons.blinkTime or 3
  me.fontSize = cons.fontSize or 9
  me.activeTabCSS = cons.activeTabCSS or ""
  me.inactiveTabCSS = cons.inactiveTabCSS or ""
  me.activeTabFGColor = cons.activeTabFGColor or "purple"
  me.inactiveTabFGColor = cons.inactiveTabFGColor or "white"
  me.activeTabBGColor = cons.activeTabBGColor or "&lt;0,180,0&gt;"
  me.inactiveTabBGColor = cons.inactiveTabBGColor or "&lt;60,60,60&gt;"
  me.consoleColor = cons.consoleColor or "black"
  me.tabBoxCSS = cons.tabBoxCSS or ""
  me.tabBoxColor = cons.tabBoxColor or "black"
  me.consoleContainerCSS = cons.consoleContainerCSS or ""
  me.consoleContainerColor = cons.consoleContainerColor or "black"
  me.gap = cons.gap or 1
  me.consoles = cons.consoles
  me.tabHeight = cons.tabHeight or 25
  if cons.autoWrap == nil then
    me.autoWrap = true
  else
    me.autoWrap = cons.autoWrap
  end
  me.wrapAt = cons.wrapAt or 300
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.windows = {}
  self.blinkTimerID = tempTimer(me.blinkTime, function() me:doBlink() end, true)
  me:reset()
  if me.allTab then me:setAllTabName(me.allTabName or me.consoles[1]) end
  table.insert(EMCOHelper.items, me)
  return me
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>UI Setup</name>
				<packageName></packageName>
				<script>--Holds the functions to setup all the UI containers
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Field Info (eotui.fieldSetup)</name>
					<packageName></packageName>
					<script>function eotui.fieldSetup()
  eotui.fieldInfo =
    eotui.fieldInfo or Geyser.HBox:new({name = "eotui.fieldInfo"}, eotui.fieldInfoContainer)
  --
  eotui.fieldInfo:move(0, 0)
  eotui.fieldInfo:resize("-0", "100%")
  --Now we will make each field its own miniconsole and then just set background color
  eotui.field1 =
    eotui.field1 or
    Geyser.MiniConsole:new(
      {name = "eotui.field1", x = 0, y = 0, width = "15%", height = "100%"}, eotui.fieldInfo
    )
  eotui.field1:setColor("black")
  eotui.field2 =
    eotui.field2 or
    Geyser.MiniConsole:new(
      {name = "eotui.field2", x = "20%", y = 0, width = "15%", height = "100%"}, eotui.fieldInfo
    )
  eotui.field2:setColor("black")
  eotui.field3 =
    eotui.field3 or
    Geyser.MiniConsole:new(
      {name = "eotui.field3", x = "40%", y = 0, width = "15%", height = "100%"}, eotui.fieldInfo
    )
  eotui.field3:setColor("black")
  eotui.field4 =
    eotui.field4 or
    Geyser.MiniConsole:new(
      {name = "eotui.field4", x = "60%", y = 0, width = "15%", height = "100%"}, eotui.fieldInfo
    )
  eotui.field4:setColor("black")
  eotui.field5 =
    eotui.field5 or
    Geyser.MiniConsole:new(
      {name = "eotui.field5", x = "80%", y = 0, width = "15%", height = "100%"}, eotui.fieldInfo
    )
  eotui.field5:setColor("black")
end

registerAnonymousEventHandler("containers_created", "eotui.fieldSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map Docking (eotui.dockMap/eotui.dockMapCombined)</name>
					<packageName></packageName>
					<script>function eotui.dockMap()
  eotui.mapwindow =
    eotui.mapwindow or Geyser.Mapper:new({name = "eotui.mapwindow"}, eotui.mapperContainer)
  -- this places the map window inside our container for it.
  eotui.mapwindow:move(0, 0)
  eotui.mapwindow:resize("-0", "100%")
end

--used for when the combined field/map option is used
function eotui.dockMapCombined()
  eotui.combMapWindow =
    eotui.combMapWindow or Geyser.Mapper:new({name = "eotui.combMapWindow"}, eotui.testWindow)
  -- this places the map window inside our container for it.
  eotui.combMapWindow:move(0, "8%")
  eotui.combMapWindow:resize("-0", "92%")
end


registerAnonymousEventHandler("containers_created", "eotui.dockMap")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Inventory (eotui.invSetup)</name>
					<packageName></packageName>
					<script>function eotui.invSetup()
  eotui.invContainer =
    eotui.invContainer or
    Geyser.MiniConsole:new(
      {name = "eotui.invContainer", scrollbar = true, fontsize = eotui.settings.invfontsize},
      eotui.invHolder
    )
  eotui.invContainer:move(0, 0)
  eotui.invContainer:resize("-0", "100%")
  eotui.invContainer:setColor(eotui.settings.winbackcolor)
end

registerAnonymousEventHandler("containers_created", "eotui.invSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Stats (eotui.statsSetup)</name>
					<packageName></packageName>
					<script>function eotui.statsSetup()
  eotui.stats =
    eotui.stats or
    Geyser.MiniConsole:new(
      {name = "eotui.stats", scrollbar = false, fontsize = eotui.settings.statsfontsize},
      eotui.statsContainer
    )
  eotui.stats:move(0, 0)
  eotui.stats:resize("-0", "100%")
  eotui.stats:setColor(eotui.settings.winbackcolor)
end

registerAnonymousEventHandler("containers_created", "eotui.statsSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Affects (eotui.affInfoSetup)</name>
					<packageName></packageName>
					<script>function eotui.affInfoSetup()
  eotui.affInfoBuff =
    eotui.affInfoBuff or
    Geyser.MiniConsole:new(
      {name = "eotui.affInfoBuff", scrollbar = true, fontsize = 10}, eotui.affInfoContainer
    )
  eotui.affInfoBuff:move(0, 0)
  --uncomment below and relace to put in other window.
  --eotui.affInfoBuff:resize("50%", "100%")
  eotui.affInfoBuff:resize("100%", "100%")
  eotui.affInfoBuff:setColor(eotui.settings.winbackcolor)
  
  --uncomment below to add in debuff window.
  --eotui.affInfoDebuff =
  --  eotui.affInfoDebuff or
  --  Geyser.MiniConsole:new(
  --    {name = "eotui.affInfoDebuff", scrollbar = true, fontsize = 10},
  --    eotui.affInfoContainer
  --  )
  --eotui.affInfoDebuff:move("50%", 0)
  --eotui.affInfoDebuff:resize("50%", "100%")
end

registerAnonymousEventHandler("containers_created", "eotui.affInfoSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>HP Gauge (eotui.hpGaugeSetup)</name>
					<packageName></packageName>
					<script>function eotui.hpGaugeSetup()
  eotui.vitals.hp_gauge =
    eotui.vitals.hp_gauge or Geyser.Gauge:new({name = "eotui.vitals.hp_gauge"}, eotui.vitals.hp)
  eotui.vitals.hp_gauge:move(0, 0)
  eotui.vitals.hp_gauge:resize("100%", "100%")
  eotui.vitals.hp_gauge.front:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ff0d00, stop: 1 #c93830);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 1;
  ]]
  )
  eotui.vitals.hp_gauge.back:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #361816, stop: 1 #9c3732);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 3;
  ]]
  )
  eotui.vitals.hp_gauge.text:setStyleSheet(
    [[
      QLabel{
				qproperty-alignment: 'AlignVCenter | AlignCenter';
				font-family: ]] ..
    eotui.settings.fonttype ..
    [[;
      }
    ]]
  )
  eotui.vitals.hp_gauge.text:setFontSize(eotui.settings.gaugefontsize)
  eotui.vitals.hp_gauge.text:echo(
    eotui.vitals.curhealth .. "/" .. eotui.vitals.maxhealth, "black", "b"
  )
end

registerAnonymousEventHandler("containers_created", "eotui.hpGaugeSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Mp Gauge (eotui.manaGaugeSetup)</name>
					<packageName></packageName>
					<script>function eotui.manaGaugeSetup()
  eotui.vitals.mp_gauge =
    eotui.vitals.mp_gauge or Geyser.Gauge:new({name = "eotui.vitals.mp_gauge"}, eotui.vitals.mp)
  eotui.vitals.mp_gauge:move(0, 0)
  eotui.vitals.mp_gauge:resize("100%", "100%")
  eotui.vitals.mp_gauge.front:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #3880a7, stop: 1 #7dbfe2);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 1;
  ]]
  )
  eotui.vitals.mp_gauge.back:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #232f35, stop: 1 #4b5e68);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 3;
  ]]
  )
  eotui.vitals.mp_gauge.text:setStyleSheet(
    [[
      QLabel{
				qproperty-alignment: 'AlignVCenter | AlignCenter';
				font-family: ]] ..
    eotui.settings.fonttype ..
    [[;
      }
    ]]
  )
  eotui.vitals.mp_gauge.text:setFontSize(eotui.settings.gaugefontsize)
  eotui.vitals.mp_gauge.text:echo(eotui.vitals.curmana .. "/" .. eotui.vitals.maxmana, "black", "b")
end

registerAnonymousEventHandler("containers_created", "eotui.manaGaugeSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Chat Box (eotui.chatBoxSetup)</name>
					<packageName></packageName>
					<script>function eotui.chatBoxSetup()
  local stylesheet =
    [[background-color: rgb(0,180,0,255); border-width: 1px; border-style: solid; border-color: gold; border-radius: 10px;]]
  local istylesheet =
    [[background-color: rgb(60,60,60,255); border-width: 1px; border-style: solid; border-color: gold; border-radius: 10px;]]
  eotui.chatContainer =
    eotui.chatContainer or
    EMCO:new(
      {
        x = "0",
        y = "0",
        width = "100%",
        height = "100%",
        allTab = true,
        allTabName = "All",
        blankLine = true,
        scrollbars = true,
        gap = 2,
        consoleColor = eotui.settings.winbackcolor,
        consoles = {"All", "OOC", "Tells", "Auction", "Says"},
        activeTabCSS = stylesheet,
        inactiveTabCSS = istylesheet,
      },
      eotui.chatbox
    )
end

registerAnonymousEventHandler("containers_created", "eotui.chatBoxSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Enemy Gauge (eotui.drawEnemyGauges)</name>
					<packageName></packageName>
					<script>function eotui.drawEnemyGauges()
  eotui.enemy.hp_gauge =
    eotui.enemy.hp_gauge or Geyser.Gauge:new({name = "eotui.enemy.hp_gauge"}, eotui.enemybar)
  eotui.enemy.hp_gauge:move(0, 0)
  eotui.enemy.hp_gauge:resize("100%", "100%")
  eotui.enemy.hp_gauge.front:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ff0d00, stop: 1 #c93830);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 1;
  ]]
  )
  eotui.enemy.hp_gauge.back:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #361816, stop: 1 #9c3732);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 3;
  ]]
  )
  eotui.enemy.hp_gauge.text:setStyleSheet(
    [[
      QLabel{
				qproperty-alignment: 'AlignVCenter | AlignCenter';
				font-family: ]] ..
    eotui.settings.fonttype ..
    [[;
      }
    ]]
  )
  eotui.enemy.maxhealth = 100
  eotui.enemy.curhealth = 100
  eotui.enemy.hp_gauge.text:setFontSize(eotui.settings.tabfontsize)
  if msdp.OPPONENT_HEALTH ~= 0 then
    eotui.enemy.hp_gauge.text:echo(
      "Lvl " ..
      msdp.OPPONENT_LEVEL ..
      " " ..
      tostring(msdp.OPPONENT_NAME) ..
      "   " ..
      eotui.enemy.curhealth ..
      "/" ..
      eotui.enemy.maxhealth ..
      "HP",
      "black",
      "b"
    )
    eotui.enemybar:show()
  else
    eotui.enemy.hp_gauge.text:echo("", "black", "b")
    eotui.enemybar:hide()
  end
end

registerAnonymousEventHandler("containers_created", "eotui.drawEnemyGauges")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Settings (eotui.settingsBoxSetup)</name>
					<packageName></packageName>
					<script>function eotui.settingsBoxSetup()
  local stylesheet =
    [[background-color: rgb(128,179,255,255); border-width: 1px; border-style: solid; border-color: white; border-radius: 10px;]]
  local istylesheet =
    [[background-color: rgb(60,60,60,255); border-width: 1px; border-style: solid; border-color: white; border-radius: 10px;]]
  eotui.settingsBox =
    eotui.settingsBox or
    EMCO:new(
      {
        x = "0",
        y = "0",
        width = "100%",
        height = "100%",
        allTab = false,
        scrollbars = true,
        fontSize = 8,
        gap = 2,
        consoleColor = eotui.settings.winbackcolor,
        consoles = {"General", "Layout", "Font", "Colors", "Stats"},
        activeTabCSS = stylesheet,
        inactiveTabCSS = istylesheet,
      },
      eotui.settingsContainer
    )
end

raiseEvent("settingsBox_created")
registerAnonymousEventHandler("containers_created", "eotui.settingsBoxSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Stats/Inv Combined (eotui.statsInvContainerSetup)</name>
					<packageName></packageName>
					<script>function eotui.statsInvContainerSetup()
  local stylesheet =
    [[background-color: rgb(128,179,255,255); border-width: 1px; border-style: solid; border-color: white; border-radius: 10px;]]
  local istylesheet =
    [[background-color: rgb(60,60,60,255); border-width: 1px; border-style: solid; border-color: white; border-radius: 10px;]]
  eotui.statsInvContainer =
    eotui.statsInvContainer or
    EMCO:new(
      {
        x = "0",
        y = "0",
        width = "100%",
        height = "100%",
        allTab = false,
        scrollbars = true,
        fontSize = 8,
        gap = 2,
        consoleColor = eotui.settings.winbackcolor,
        consoles = {"Stats", "Inventory"},
        activeTabCSS = stylesheet,
        inactiveTabCSS = istylesheet,
      },
      eotui.statsInvCombined
    )
end

registerAnonymousEventHandler("containers_created", "eotui.statsInvContainerSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Morph Gauge Setup (eotui.morphGaugeSetup)</name>
					<packageName></packageName>
					<script>function eotui.morphGaugeSetup()
  eotui.morph_gauge =
    eotui.morph_gauge or Geyser.Gauge:new({name = "eotui.morph_gauge"}, eotui.morphContainer)
  eotui.morph_gauge:move(0, 0)
  eotui.morph_gauge:resize("100%", "100%")
  eotui.morph_gauge.front:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #7f2ca8, stop: 1 #af79c9);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 3;
    padding: 1;
  ]]
  )
  eotui.morph_gauge.back:setStyleSheet(
    [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #401654, stop: 1 #221429);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 3;
  ]]
  )
  eotui.morph_gauge.text:setStyleSheet(
    [[
      QLabel{
				qproperty-alignment: 'AlignVCenter | AlignCenter';
				font-family: ]] ..
    eotui.settings.fonttype ..
    [[;
      }
    ]]
  )
  eotui.morph_gauge.text:setFontSize(eotui.settings.gaugefontsize)
  eotui.morph_gauge.text:echo(eotui.vitals.curmorph .. "/" .. eotui.vitals.maxmorph, "black", "b")
end


registerAnonymousEventHandler("containers_created", "eotui.morphGaugeSetup")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Field/Map Combined (eotui.fieldMapContainerSetup)</name>
					<packageName></packageName>
					<script>function eotui.fieldMapContainerSetup()
  --begin setup of field info container
  eotui.combFieldMapTop =
    eotui.combFieldMapTop or
    Geyser.HBox:new({name = "eotui.combFieldMapTop"}, eotui.fieldMapCombined)
  eotui.combFieldMapTop:move(0, 0)
  eotui.combFieldMapTop:resize("-0", "8%")
  eotui.combFieldMapBottom =
    eotui.combFieldMapBottom or
    Geyser.Container:new({name = "eotui.combFieldMapBottom"}, eotui.fieldMapCombined)
  eotui.combFieldMapBottom:move(0, "9%")
  eotui.combFieldMapBottom:resize("-0", "92%")
  eotui.combField1 =
    eotui.combField1 or
    Geyser.MiniConsole:new(
      {name = "eotui.combField1", x = 0, y = 0, width = "15%", height = "100%"},
      eotui.combFieldMapTop
    )
  eotui.combField1:setColor("black")
  eotui.combField2 =
    eotui.combField2 or
    Geyser.MiniConsole:new(
      {name = "eotui.combField2", x = "20%", y = 0, width = "15%", height = "100%"},
      eotui.combFieldMapTop
    )
  eotui.combField2:setColor("white")
  eotui.combField3 =
    eotui.combField3 or
    Geyser.MiniConsole:new(
      {name = "eotui.combField3", x = "40%", y = 0, width = "15%", height = "100%"},
      eotui.combFieldMapTop
    )
  eotui.combField3:setColor("green")
  eotui.combField4 =
    eotui.combField4 or
    Geyser.MiniConsole:new(
      {name = "eotui.combField4", x = "60%", y = 0, width = "15%", height = "100%"},
      eotui.combFieldMapTop
    )
  eotui.combField4:setColor("yellow")
  eotui.combField5 =
    eotui.combField5 or
    Geyser.MiniConsole:new(
      {name = "eotui.combField5", x = "80%", y = 0, width = "15%", height = "100%"},
      eotui.combFieldMapTop
    )
  eotui.combField5:setColor("red")
  --begin setup of EMCO container for mapper/worldmap
  local stylesheet =
    [[background-color: rgb(128,179,255,255); border-width: 1px; border-style: solid; border-color: white; border-radius: 10px;]]
  local istylesheet =
    [[background-color: rgb(60,60,60,255); border-width: 1px; border-style: solid; border-color: white; border-radius: 10px;]]
  eotui.fieldMapContainer =
    eotui.fieldMapContainer or
    EMCO:new(
      {
        x = "0",
        y = "0",
        width = "100%",
        height = "100%",
        allTab = false,
        scrollbars = false,
        fontSize = 8,
        gap = 2,
        consoleColor = eotui.settings.winbackcolor,
        consoles = {"Mapper", "World Map"},
        mapTabName = "Mapper",
        mapTab = true,
        activeTabCSS = stylesheet,
        inactiveTabCSS = istylesheet,
      },
      --eotui.fieldMapCombined
      eotui.combFieldMapBottom
    )
    
  if eotui.settings.combineFieldMap == false then
    eotui.fieldMapCombined:hide()
  end
end


registerAnonymousEventHandler("containers_created", "eotui.fieldMapContainerSetup")</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Settings System</name>
					<packageName></packageName>
					<script>-- Holds everything dealing with the settings window</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>General Settings (eotui.generalSettings)</name>
						<packageName></packageName>
						<script>-- General Settings

function eotui.generalSettings()

end

registerAnonymousEventHandler("settingsBox_created", "eotui.generalSettings")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Layout Settings (eotui.settingsMenuLayoutSettings)</name>
						<packageName></packageName>
						<script>--Hold layout settings

function eotui.settingsMenuSaveLayout()
  Adjustable.Container:saveAll()
  info("Layout Saved")
end

function eotui.settingsMenuLoadLayout()
  Adjustable.Container:loadAll()
  if eotui.settings.combineStatsInv == false then
    eotui.settingsMenuLayoutSettings()
    eotui.statsInvCombined:hide()
    eotui.statsContainer:show()
    eotui.invHolder:show()
    eotui.invUpdate()
    eotui.updateCharStats()
  else
    eotui.settingsMenuLayoutSettings()
    eotui.statsContainer:hide()
    eotui.invHolder:hide()
    eotui.statsInvContainerSetup()
    eotui.statsInvCombined:show()
    eotui.invUpdate()
    eotui.updateCharStats()
  end
  if eotui.settings.combineFieldMap == false then
    eotui.settingsMenuLayoutSettings()				  --refresh layout screen
    eotui.fieldMapCombined:hide()		--hide combined field/map box
    eotui.fieldInfoContainer:show()	--show field info container
    eotui.mapperContainer:show()		--show mapper container
	  eotui.fieldMapContainer:disableMapTab()
    eotui.dockMap()						      --dock mapper to container
    eotui.updateFieldInfo()				  --update field info
  else
    eotui.settingsMenuLayoutSettings()				  --refresh layout screen
    eotui.fieldMapCombined:show()		--show combined field/map box
	  eotui.fieldInfoContainer:hide() --hide field info container
	  eotui.mapperContainer:hide()		--hide mapper container
	  eotui.fieldMapContainer:enableMapTab()
	  eotui.updateFieldInfo()				  --update field info
  end
  info("Layout loaded")
end

function eotui.settingsMenuSwapFieldMap()
  if eotui.settings.combineFieldMap== true then
    eotui.settings.combineFieldMap = false
    eotui.settingsMenuLayoutSettings()				  --refresh layout screen
    eotui.fieldMapCombined:hide()		--hide combined field/map box
    eotui.fieldInfoContainer:show()	--show field info container
    eotui.mapperContainer:show()		--show mapper container
	  eotui.dockMap()						      --dock mapper to container
    eotui.updateFieldInfo()				  --update field info
  else
    eotui.settings.combineFieldMap = true
    eotui.settingsMenuLayoutSettings()				  --refresh layout screen
    eotui.fieldMapCombined:show()		--show combined field/map box
	  eotui.fieldInfoContainer:hide() --hide field info container
	  eotui.mapperContainer:hide()		--hide mapper container
	  eotui.
    --eotui.dockMapCombined()				--dock mapper to combined window
	  eotui.updateFieldInfo()				  --update field info
  end
end

function eotui.settingsMenuSwapStatsInv()
  if eotui.settings.combineStatsInv == true then
    eotui.settings.combineStatsInv = false
    eotui.settingsMenuLayoutSettings()
    eotui.statsInvCombined:hide()
    eotui.statsContainer:show()
    eotui.invHolder:show()
    eotui.invUpdate()
    eotui.updateCharStats()
  else
    eotui.settings.combineStatsInv = true
    eotui.settingsMenuLayoutSettings()
    eotui.statsContainer:hide()
    eotui.invHolder:hide()
    eotui.statsInvContainerSetup()
    eotui.statsInvCombined:show()
    eotui.invUpdate()
    eotui.updateCharStats()
  end
end


function eotui.settingsMenuLayoutSettings()
  eotui.settingsBox.windows.Layout:clear()
  local save_line = "-----------------"
  local save_column = "-"
  local line_break = "\n"
  local spacer = " "

  eotui.settingsBox:cechoLink(
    "Layout", "Combine Stats and Inv Boxes: ".. tostring(eotui.settings.combineStatsInv) .."", [[eotui.settingsMenuSwapStatsInv()]], "Combine Stats and Inv Boxes"
  )
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:cechoLink(
    "Layout", "Combine Field and Mapper Boxes: ".. tostring(eotui.settings.combineFieldMap) .."", [[eotui.settingsMenuSwapFieldMap()]], "Combine Field and Mapper Boxes"
  )
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:echo("Layout", line_break)
  eotui.settingsBox:echo("Layout", save_column)
  eotui.settingsBox:cechoLink(
    "Layout", " Save Layout ", [[eotui.settingsMenuSaveLayout()]], "Save Layout"
  )
  eotui.settingsBox:echo("Layout", save_column)
  eotui.settingsBox:echo("Layout", "  ")
  eotui.settingsBox:echo("Layout", save_column)
  eotui.settingsBox:cechoLink(
    "Layout", " Load Layout ", [[eotui.settingsMenuLoadLayout()]], "Loads Layout"
  )
  eotui.settingsBox:echo("Layout", save_column)
  eotui.settingsBox:echo("Layout", line_break)
end

registerAnonymousEventHandler("settingsBox_created", "eotui.settingsMenuLayoutSettings")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Font Settings (eotui.fontSettings)</name>
						<packageName></packageName>
						<script>function eotui.fontSettings()

end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Color Settings (eotui.colorSettings)</name>
						<packageName></packageName>
						<script>--All color settings

function eotui.colorSettings()

end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Stats Settings (eotui.statsSettings)</name>
						<packageName></packageName>
						<script>--Customize what is shown in the stats box

function eotui.statsSettings()

end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>MSDP Update Functions</name>
				<packageName></packageName>
				<script>--Holds all the functions for updating info based on 
--MSDP recieves</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Communications</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>OOC (eotui.chatOOC)</name>
						<packageName></packageName>
						<script>function eotui.chatOOC()
  local replace = ansi2decho(msdp.OOC)
  eotui.chatContainer:decho("OOC", replace)
end

registerAnonymousEventHandler("msdp.OOC", "eotui.chatOOC")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Tells (eotui.chatTells)</name>
						<packageName></packageName>
						<script>function eotui.chatTells()
  local replace = ansi2decho(msdp.TELL)
  eotui.chatContainer:decho("Tells", replace)
end

registerAnonymousEventHandler("msdp.TELL", "eotui.chatTells")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Replies (eotui.chatReplies)</name>
						<packageName></packageName>
						<script>function eotui.chatReplies()
  local replace = ansi2decho(msdp.REPLY)
  eotui.chatContainer:decho("Tells", replace)
end

registerAnonymousEventHandler("msdp.REPLY", "eotui.chatReplies")</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Field (eotui.updateFieldInfo)</name>
					<packageName></packageName>
					<script>--	pulls the field data and changes the background color to match
--	they are reverse what they appear on the screen so order is actually:
--  4 3 2 1 0

function eotui.updateFieldInfo()
  eotui.field1:setColor(tostring(msdp.FIELD4))
  eotui.field2:setColor(tostring(msdp.FIELD3))
  eotui.field3:setColor(tostring(msdp.FIELD2))
  eotui.field4:setColor(tostring(msdp.FIELD1))
  eotui.field5:setColor(tostring(msdp.FIELD0))
  if tostring(msdp.LOCKED) == "yes" then
    eotui.field1:cecho("\n&lt;black:white&gt;LOCKED")
    eotui.field2:cecho("\n&lt;black:white&gt;LOCKED")
    eotui.field3:cecho("\n&lt;black:white&gt;LOCKED")
    eotui.field4:cecho("\n&lt;black:white&gt;LOCKED")
    eotui.field5:cecho("\n&lt;black:white&gt;LOCKED")
  else
    clearWindow("eotui.field1")
    clearWindow("eotui.field2")
    clearWindow("eotui.field3")
    clearWindow("eotui.field4")
    clearWindow("eotui.field5")
  end
end

registerAnonymousEventHandler("msdp.FIELD4", "eotui.updateFieldInfo")
registerAnonymousEventHandler("msdp.FIELD3", "eotui.updateFieldInfo")
registerAnonymousEventHandler("msdp.FIELD2", "eotui.updateFieldInfo")
registerAnonymousEventHandler("msdp.FIELD1", "eotui.updateFieldInfo")
registerAnonymousEventHandler("msdp.FIELD0", "eotui.updateFieldInfo")
registerAnonymousEventHandler("msdp.LOCKED", "eotui.updateFieldInfo")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Inventory (eotui.invUpdate)</name>
					<packageName></packageName>
					<script>function eotui.invUpdate()
	-- make size of the msdp.INVENTORY table as the max inventory
	-- makes it so that the script will cycle thru all the inventory
	-- entries.
	local max_inventory_size = #msdp.INVENTORY
	local current_inventory = 1
	local hdr = eotui.settings.colors.header
  
	if eotui.settings.combineStatsInv == false then
		clearWindow("eotui.invContainer")
		eotui.invContainer:cecho(demonnic:cfText("&lt;"..hdr.."&gt; Inventory", {alignment="center", width =28, inside=false}))
		for index,item in ipairs(msdp.INVENTORY) do
			if tostring(item.LOCATION) == "Inventory" then
				if tonumber(item.COUNT) &gt;= 2 then
					cecho ("eotui.invContainer", "\n("..item.COUNT..") "..item.NAME .. "")
				else
					cecho ("eotui.invContainer", "\n"..item.NAME.."")
				end
			end
		end
	else
		eotui.statsInvContainer.windows.Inventory:clear()
		for index,item in ipairs(msdp.INVENTORY) do
			if tostring(item.LOCATION) == "Inventory" then
				if tonumber(item.COUNT) &gt;= 2 then
					eotui.statsInvContainer:cecho ("Inventory", "\n("..item.COUNT..") "..item.NAME .. "")
				else
					eotui.statsInvContainer:cecho ("Inventory", "\n"..item.NAME.."")
				end
			end
		end
	end
end
registerAnonymousEventHandler("msdp.INVENTORY", "eotui.invUpdate")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Stats (eotui.updateCharStats)</name>
					<packageName></packageName>
					<script>function eotui.updateCharStats()

	local char_level = tonumber(msdp.LEVEL)

	local hdr = eotui.settings.colors.header
	local emp = eotui.settings.colors.emphasis
	local div = eotui.settings.colors.divider
	local gpc = eotui.settings.colors.gold
	local spc = eotui.settings.colors.exp
	local glc = eotui.settings.colors.guild
	local trains_avail = msdp.AP / 10

	if trains_avail &lt; 1 then
			trains_avail = 0
	end

		if eotui.settings.combineStatsInv == false then
		clearWindow("eotui.stats")
		if msdp.CHARACTER_NAME ~= nil then
			cecho("eotui.stats", demonnic:cfText("&lt;"..hdr.."&gt;"..msdp.CHARACTER_NAME.."", {alignment="center", width =50, inside=false}))
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Race&lt;"..div.."&gt;: "..tostring(msdp.RACE).."    ", [[send("help human")]], ""..tostring(msdp.RACE).." Race", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Class&lt;"..div.."&gt;: "..tostring(msdp.CLASS).."", [[send("help "..msdp.CLASS.."s")]], ""..tostring(msdp.CLASS).." Class", true)
			cecho("eotui.stats", "\n")
			cecho("eotui.stats", "&lt;"..emp.."&gt;Level&lt;"..div.."&gt;: "..msdp.LEVEL.. "&lt;"..emp.."&gt;     TNL&lt;"..div.."&gt;: "..msdp.EXPERIENCE_TNL.."\n")
			cecho("eotui.stats", "&lt;"..emp.."&gt;GIL&lt;"..div.."&gt;: "..msdp.GIL.. "&lt;"..emp.."&gt;       Bank&lt;"..div.."&gt;: "..msdp.BANK.. "&lt;"..emp.."&gt;      AP&lt;"..div.."&gt;: "..msdp.AP.."("..trains_avail..")\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Items&lt;"..div.."&gt;: "..tonumber(msdp.ITEM_HELD_CUR).."/"..tonumber(msdp.ITEM_HELD_MAX).."   ", [[send("")]], "Current/Max Items you can hold.\nAffected by AGI", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Weight&lt;"..div.."&gt;: "..tonumber(msdp.ITEM_WEIGHT_CUR).."/"..tonumber(msdp.ITEM_WEIGHT_MAX).."   ", [[send("")]], "Current/Max Weight you can hold.\nAffected by PWR", true)
			cecho("eotui.stats", "\n")
			cecho("eotui.stats", "\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Pwr&lt;"..div.."&gt;: "..tonumber(msdp.PWR).."    ", [[send("help pwr")]], "Atk Power and weight you can carry", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Vit&lt;"..div.."&gt;: "..tonumber(msdp.VIT).."    ", [[send("help vit")]], "HP per level and defense", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Wil&lt;"..div.."&gt;: "..tonumber(msdp.WIL).."    ", [[send("help wil")]], "Magic Damage, skill learning, accuracy\nand some misc.", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Agi&lt;"..div.."&gt;: "..tonumber(msdp.AGI).."    ", [[send("help agility")]], "Evasion and evasion based skills, \nand speed of attack rounds.\nAlso affects Crit Rate and Amount of Items you can hold", true)
			cecho("eotui.stats", "\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Atk&lt;"..div.."&gt;: "..tonumber(msdp.ATTACK).."    ", [[send("help vit attack")]], "Weapon Strength and PWR and some\nother factors that determins how powerful\nyour attacks are.", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Acc&lt;"..div.."&gt;: "..tonumber(msdp.ACCURACY).."    ", [[send("help accuracy")]], "WIL, level, weapon or hand to hand skill and\nother misc bonuses and skills. Is used in\ntotal hitrate", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Spd&lt;"..div.."&gt;: "..tonumber(msdp.SPEED).."    ", [[send("help spd attack")]], "Primarily based on AGI, represents how fast \ncombat rounds occur", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Mob&lt;"..div.."&gt;: "..tonumber(msdp.MOBILITY).."    ", [[send("help mobility")]], "Gained from equipment, increases chances for \nmore attack in combat", true)
			cecho("eotui.stats", "\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Cast Lvl&lt;"..div.."&gt;: "..tonumber(msdp.CASTLVL).."    ", [[send("help cast level")]], "Combination of WIL and Lvl that determines\nat what level you cast spells", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt; Cast Cap&lt;"..div.."&gt;: "..tonumber(msdp.CASTCAP).."    ", [[send("help cast cap")]], "From VIT, casting a spell level over your cap\n will inflict damage on you in relation to\nhow far over the cap you go", true)
			cecho("eotui.stats", "\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Crit Rate&lt;"..div.."&gt;: "..tonumber(msdp.CRIT_RATE).."    ", [[send("help critical health")]], "Class, AGI (or with projectiles AGI &amp; WIS)\nvarious merits/flaws, what hand a weapon is in\nand weapon flags like sharp.\nmax possible 255", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Crit Power&lt;"..div.."&gt;: "..tonumber(msdp.CRIT_POWER).."    ", [[send("help crit power")]], "Strength of Crit Hits landed. Base of 100, affected\nby various skills and merits along as where \nthe weapon is equipped", true)
			cecho("eotui.stats", "\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Phys Def&lt;"..div.."&gt;: "..tonumber(msdp.DEFENSE).."    ", [[send("help defense")]], "Affected by Equipment, VIT, and misc. skills.\nDetermines how much damage taken from hits.\nArmor Skills can increase effectiveness\n(see help amor skills)", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Mag Def&lt;"..div.."&gt;: "..tonumber(msdp.MDEFENSE).."    ", [[send("help defense")]], "Affected by Equipment, WIL, and misc. skills.\nDetermines how much damage taken from magic.", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Evade&lt;"..div.."&gt;: "..tonumber(msdp.EVADE).."    ", [[send("help evade")]], "Affected by AGI, compared against enemy's total hit rate to\ndetermine outcome of attack", true)
			cecho("eotui.stats", "\n")
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Parry Mitigation&lt;"..div.."&gt;: "..tonumber(msdp.MIT_PARRY).."%   ", [[send("")]], "On successful parry, adds to the damage reduction (1 pt = 1%)", true)
			cechoLink("eotui.stats", "&lt;"..emp.."&gt;Block Mitigation&lt;"..div.."&gt;: "..tonumber(msdp.MIT_BLOCK).."%    ", [[send("")]], "On successful shield block, adds to the damage reduction (1 pt = 1%)", true)
			cecho("eotui.stats", "\n")
		end
	else
		eotui.statsInvContainer.windows.Stats:clear()
		if msdp.CHARACTER_NAME ~= nil then
			eotui.statsInvContainer:cecho("Stats", demonnic:cfText("&lt;"..hdr.."&gt;"..msdp.CHARACTER_NAME.."", {alignment="center", width =50, inside=false}))
			eotui.statsInvContainer:cechoLink("Stats", "\n&lt;"..emp.."&gt;Race&lt;"..div.."&gt;: "..tostring(msdp.RACE).."    ", [[send("help human")]], ""..tostring(msdp.RACE).." Race", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Class&lt;"..div.."&gt;: "..tostring(msdp.CLASS).."", [[send("help "..msdp.CLASS.."s")]], ""..tostring(msdp.CLASS).." Class", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cecho("Stats", "&lt;"..emp.."&gt;Level&lt;"..div.."&gt;: "..msdp.LEVEL.. "&lt;"..emp.."&gt;     TNL&lt;"..div.."&gt;: "..msdp.EXPERIENCE_TNL.."\n")
			eotui.statsInvContainer:cecho("Stats", "&lt;"..emp.."&gt;GIL&lt;"..div.."&gt;: "..msdp.GIL.. "&lt;"..emp.."&gt;       Bank&lt;"..div.."&gt;: "..msdp.BANK.. "&lt;"..emp.."&gt;      AP&lt;"..div.."&gt;: "..msdp.AP.."("..trains_avail..")\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Items&lt;"..div.."&gt;: "..tonumber(msdp.ITEM_HELD_CUR).."/"..tonumber(msdp.ITEM_HELD_MAX).."   ", [[send("")]], "Current/Max Items you can hold.\nAffected by AGI", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Weight&lt;"..div.."&gt;: "..tonumber(msdp.ITEM_WEIGHT_CUR).."/"..tonumber(msdp.ITEM_WEIGHT_MAX).."   ", [[send("")]], "Current/Max Weight you can hold.\nAffected by PWR", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Pwr&lt;"..div.."&gt;: "..tonumber(msdp.PWR).."    ", [[send("help pwr")]], "Atk Power and weight you can carry", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Vit&lt;"..div.."&gt;: "..tonumber(msdp.VIT).."    ", [[send("help vit")]], "HP per level and defense", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Wil&lt;"..div.."&gt;: "..tonumber(msdp.WIL).."    ", [[send("help wil")]], "Magic Damage, skill learning, accuracy\nand some misc.", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Agi&lt;"..div.."&gt;: "..tonumber(msdp.AGI).."    ", [[send("help agility")]], "Evasion and evasion based skills, \nand speed of attack rounds.\nAlso affects Crit Rate and Amount of Items you can hold", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Atk&lt;"..div.."&gt;: "..tonumber(msdp.ATTACK).."    ", [[send("help vit attack")]], "Weapon Strength and PWR and some\nother factors that determins how powerful\nyour attacks are.", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Acc&lt;"..div.."&gt;: "..tonumber(msdp.ACCURACY).."    ", [[send("help accuracy")]], "WIL, level, weapon or hand to hand skill and\nother misc bonuses and skills. Is used in\ntotal hitrate", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Spd&lt;"..div.."&gt;: "..tonumber(msdp.SPEED).."    ", [[send("help spd attack")]], "Primarily based on AGI, represents how fast \ncombat rounds occur", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Mob&lt;"..div.."&gt;: "..tonumber(msdp.MOBILITY).."    ", [[send("help mobility")]], "Gained from equipment, increases chances for \nmore attack in combat", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Cast Lvl&lt;"..div.."&gt;: "..tonumber(msdp.CASTLVL).."    ", [[send("help cast level")]], "Combination of WIL and Lvl that determines\nat what level you cast spells", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt; Cast Cap&lt;"..div.."&gt;: "..tonumber(msdp.CASTCAP).."    ", [[send("help cast cap")]], "From VIT, casting a spell level over your cap\n will inflict damage on you in relation to\nhow far over the cap you go", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Crit Rate&lt;"..div.."&gt;: "..tonumber(msdp.CRIT_RATE).."    ", [[send("help critical health")]], "Class, AGI (or with projectiles AGI &amp; WIS)\nvarious merits/flaws, what hand a weapon is in\nand weapon flags like sharp.\nmax possible 255", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Crit Power&lt;"..div.."&gt;: "..tonumber(msdp.CRIT_POWER).."    ", [[send("help crit power")]], "Strength of Crit Hits landed. Base of 100, affected\nby various skills and merits along as where \nthe weapon is equipped", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Phys Def&lt;"..div.."&gt;: "..tonumber(msdp.DEFENSE).."    ", [[send("help defense")]], "Affected by Equipment, VIT, and misc. skills.\nDetermines how much damage taken from hits.\nArmor Skills can increase effectiveness\n(see help amor skills)", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Mag Def&lt;"..div.."&gt;: "..tonumber(msdp.MDEFENSE).."    ", [[send("help defense")]], "Affected by Equipment, WIL, and misc. skills.\nDetermines how much damage taken from magic.", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Evade&lt;"..div.."&gt;: "..tonumber(msdp.EVADE).."    ", [[send("help evade")]], "Affected by AGI, compared against enemy's total hit rate to\ndetermine outcome of attack", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Parry Mitigation&lt;"..div.."&gt;: "..tonumber(msdp.MIT_PARRY).."%   ", [[send("")]], "On successful parry, adds to the damage reduction (1 pt = 1%)", true)
			eotui.statsInvContainer:cechoLink("Stats", "&lt;"..emp.."&gt;Block Mitigation&lt;"..div.."&gt;: "..tonumber(msdp.MIT_BLOCK).."%    ", [[send("")]], "On successful shield block, adds to the damage reduction (1 pt = 1%)", true)
			eotui.statsInvContainer:cecho("Stats", "\n")
		end
	end
end


-- no pretty way to do this with the current implementation of msdp.
-- tried to include any event that would change a stat so the box would update.
registerAnonymousEventHandler("msdp.RACE", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.CLASS", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.LEVEL", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.EXPERIENCE_TNL", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.GIL", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.BANK", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.AP", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.PWR", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.VIT", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.WIL", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.AGI", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.ATTACK", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.ACCURACY", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.SPEED", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.MOBILITY", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.CASTLVL", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.CASTCAP", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.CRIT_RATE", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.CRIT_POWER", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.DEFENSE", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.MDEFENSE", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.EVADE", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.MIT_PARRY", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.MIT_BLOCK", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.ITEM_HELD_CUR", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.ITEM_HELD_MAX", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.ITEM_WEIGHT_CUR", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.ITEM_WEIGHT_MAX", "eotui.updateCharStats")
registerAnonymousEventHandler("msdp.SECTOR", "eotui.updateCharStats")
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Affects (eotui.affUp)</name>
					<packageName></packageName>
					<script>-- Update and output the things affecting us to the window, with timers!
function eotui.affUp()
	clearWindow("eotui.affInfoBuff")
	local lcc = eotui.settings.colors.lowcount
	local hcc = eotui.settings.colors.highcount
	local dec = eotui.settings.colors.defense
	local aff = eotui.settings.colors.affliction
	local div = eotui.settings.colors.divider
	-- so with how the affects are sent in EOT thru msdp
	-- k = the affect name and v is the duration (msdp.AFFECTS.k)
	if #msdp.AFFECTS ~= nil then
		for k, v in pairs(msdp.AFFECTS) do
			local durtonum = tonumber(v)
      local sectomin = math.floor(durtonum / 60)
			local mintosec = durtonum % 60
			local countcolor = ""
			if durtonum&lt;10 then countcolor = ""..lcc.."" else countcolor = ""..hcc.."" end
      if tonumber(v) == "-1"  then
        eotui.affInfoBuff:cecho("&lt;"..dec.."&gt;"..k.. "&lt;"..div.."&gt; for &lt;"..hcc.."&gt; PERM &lt;"..div.."&gt;s \n")
      else
        eotui.affInfoBuff:cecho("&lt;"..dec.."&gt;"..k.. "&lt;"..div.."&gt; for &lt;"..hcc.."&gt;" ..sectomin.. "&lt;"..div.."&gt;m&lt;"..countcolor.."&gt; "..mintosec.."&lt;"..div.."&gt;s \n")
      end
    end -- for
	end
end -- function

registerAnonymousEventHandler("msdp.AFFECTS", "eotui.affUp")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>HP/Mana (eotui.updateVitals)</name>
					<packageName></packageName>
					<script>function eotui.updateVitals()
  if not eotui.useGauges.enabled then
    return
  end
  if msdp.HEALTH ~= nil then
    if msdp.MANA ~= nil then
      eotui.vitals.curhealth, eotui.vitals.curmana = tonumber(msdp.HEALTH), tonumber(msdp.MANA)
      eotui.vitals.maxhealth, eotui.vitals.maxmana =
        tonumber(msdp.HEALTH_MAX), tonumber(msdp.MANA_MAX)
    else
      eotui.vitals.curhealth, eotui.vitals.curmana = 100, 100
      eotui.vitals.maxhealth, eotui.vitals.maxmana = 100, 100
    end
  end
  eotui.vitals.hp_gauge:setValue(eotui.vitals.curhealth, eotui.vitals.maxhealth)
  if tonumber(msdp.WAIT) ~= 0 then
    eotui.vitals.hp_gauge.text:echo(
      eotui.vitals.curhealth .. "/" .. eotui.vitals.maxhealth .. "HP         ***WAIT***",
      "black",
      "b"
    )
  else
    eotui.vitals.hp_gauge.text:echo(
      eotui.vitals.curhealth .. "/" .. eotui.vitals.maxhealth .. "HP", "black", "b"
    )
  end
  eotui.vitals.mp_gauge:setValue(eotui.vitals.curmana, eotui.vitals.maxmana)
  if tonumber(msdp.LIMIT_METER) == 100 then
    eotui.vitals.mp_gauge.text:echo(
      eotui.vitals.curmana .. "/" .. eotui.vitals.maxmana .. "MP     ***LIMIT***", "black", "b"
    )
  else
    eotui.vitals.mp_gauge.text:echo(
      eotui.vitals.curmana ..
      "/" ..
      eotui.vitals.maxmana ..
      "MP (" ..
      tonumber(msdp.LIMIT_METER) ..
      ")",
      "black",
      "b"
    )
  end
end

registerAnonymousEventHandler("msdp.HEALTH", "eotui.updateVitals")
registerAnonymousEventHandler("msdp.MANA", "eotui.updateVitals")
registerAnonymousEventHandler("msdp.HEALTH_MAX", "eotui.updateVitals")
registerAnonymousEventHandler("msdp.MANA_MAX", "eotui.updateVitals")
registerAnonymousEventHandler("msdp.WAIT", "eotui.updateVitals")
registerAnonymousEventHandler("msdp.LIMIT_METER", "eotui.updateVitals")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Enemy Info (eotui.updateEnemyInfo)</name>
					<packageName></packageName>
					<script>-- Updates our opponents life and info with mdsp

-- we have to do this slightly different cause EOT
-- sends us the opponent health in a %.
-- so we have to interpret the data as a %
-- basically making maxhealth as 100 to accurate relay.


-- "OPPONENT_HEALTH", "OPPONENT_HEALTH_MAX", "OPPONENT_LEVEL", "OPPONENT_NAME"

function eotui.updateEnemyInfo()
if not eotui.useGauges.enabled then return end
 	eotui.enemy.curhealth = tonumber(msdp.OPPONENT_HEALTH)
	eotui.enemy.maxhealth = 100
	eotui.enemy.name			= tostring(msdp.OPPONENT_NAME)
	eotui.enemy.level			= tonumber(msdp.OPPONENT_LEVEL)
 
	eotui.enemy.hp_gauge:setValue(eotui.enemy.curhealth, eotui.enemy.maxhealth)

if tonumber(msdp.OPPONENT_HEALTH) ~= 0 then
	eotui.enemy.hp_gauge.text:echo("Lvl ".. tonumber(msdp.OPPONENT_LEVEL) .. " " .. tostring(msdp.OPPONENT_NAME) .. "   ".. eotui.enemy.curhealth .. "% HP","black", "b")
	eotui.enemybar:show()
end

if tonumber(msdp.OPPONENT_HEALTH) == 0 then
  eotui.enemy.hp_gauge.text:echo("","black", "b")
	eotui.enemybar:hide()
end

end
	
registerAnonymousEventHandler("msdp.OPPONENT_HEALTH", "eotui.updateEnemyInfo")
registerAnonymousEventHandler("msdp.OPPONENT_LEVEL", "eotui.updateEnemyInfo")
registerAnonymousEventHandler("msdp.OPPONENT_NAME", "eotui.updateEnemyInfo")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Morph Counter (eotui.updateMorph)</name>
					<packageName></packageName>
					<script>function eotui.updateMorph()
  if not eotui.useGauges.enabled then
    return
  end
  if msdp.MORPH ~= nil then
    eotui.vitals.curmorph = tonumber(msdp.MORPH)
    eotui.vitals.maxmorph = 100
  else
    eotui.vitals.curmorph = 100
    eotui.vitals.maxmorph = 100
  end
  eotui.morph_gauge:setValue(eotui.vitals.curmorph, eotui.vitals.maxmorph)
  eotui.morph_gauge.text:echo(
    eotui.vitals.curmorph .. "/" .. eotui.vitals.maxmorph .. " Morph Time", "white", "b"
  )
end

registerAnonymousEventHandler("msdp.MORPH", "eotui.updateMorph")</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Eot Mapper</name>
				<packageName></packageName>
				<script>mudlet = mudlet or {}; mudlet.mapper_script = true</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Create Option Table</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function createOption(startingValue, onChangeFunc, allowedVarTypes, use, checkOption, games)
	if allowedVarTypes then -- make sure our starting Value follows type rules
		if not table.contains(allowedVarTypes, type(startingValue)) then
			echo("Starting type is not of allowed type!\n")
			display(allowedVarTypes)
			echo("type: " .. type(startingValue) .. "\n")
			return
		end
	end

	local option = {
		value = startingValue,
		onChange = onChangeFunc,
		allowedVarTypes = allowedVarTypes,
		use = use or "",
		games = games,
		checkOption = checkOption or function() return true end
      
	}

	return option
end

function createOptionsTable(defaultTable)
	local index = {} -- index to store the default table at in our proxy table


	local proxyTable = {} -- This is the table that is returned to the user

	proxyTable.disp = echo

	proxyTable.dispDefaultWriteError = function()
		echo("Can't overwrite default options. Please use the SetOption function to change the value\n")
	end

	proxyTable.dispOption = function(opt, val)
		if not opt or not val then return end
		echo("Name: " .. string.title(opt) .. string.rep(" ", 10 - string.len(opt)))
		echo("Val: " .. tostring(val.value))
		echo(string.rep(" ", 10 - string.len(tostring(val.value))) ..  "- " .. val.use .. "\n")
	end

	function proxyTable:showAllOptions(game)
		proxyTable.disp("Available options: \n")
		for k, v in pairs(self[index]) do
			if not game or not v.games or v.games[game] then
				self.dispOption(k, v)
			end
		end
		echo("\n")
		for k, v in pairs(self["_customOptions"]) do
			self.dispOption(k, v)
		end

	end

	function proxyTable:getAllOptions()
		local t = {}
		for k, v in pairs(self[index]) do
			t[k] = v.value
		end

		return t
	end

   function proxyTable:setOption(option, value, silent)
		if self[option] == nil then
			proxyTable.disp("No such option!\n")
			return
		end

		-- otherwise, set the option
		if self["_customOptions"][option] then
			if not (table.contains(self["_customOptions"][option].allowedVarTypes, type(value)) and self["_customOptions"][option].checkOption(value)) then
				proxyTable.disp("You can't set '" .. option .. "' to that!\n")
				return
			end
			self["_customOptions"][option].value = value
			if self["_customOptions"][option].onChange then
				self["_customOptions"][option].onChange(option, value)
			end
		else
			if not (table.contains(self[index][option].allowedVarTypes, type(value)) and self[index][option].checkOption(value)) then
				proxyTable.disp("You can't set '" .. option .. "' to that!\n")
				return
			end
			rawset(self[index][option], "value", value)
			local opt = rawget(self[index], option)
			if opt.onChange  and not silent then opt.onChange(option, value) end
		end
		if mmp and mmp.clearpathcache then mmp.clearpathcache() end
	end


	proxyTable._customOptions = {}

	local mt = {
		__index = function(t, k)
			local custOp = rawget(t, "_customOptions")
			if custOp[k] then
			 	local opt = custOp[k]
				if opt then return opt.value else return nil end
			else
				local opt = t[index][k]
				if opt then return opt.value else return nil end
			end
		end,

		__newindex = function (t, k, v)
			if t[index][k] then
				proxyTable.dispDefaultWriteError()
			else
				t["_customOptions"][k] = v
			end
		end
	}


	proxyTable[index] = defaultTable

	setmetatable(proxyTable, mt)

	return proxyTable

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Load settings</name>
					<packageName></packageName>
					<script>-- mmp = mudlet mapper namespace
mmp =
  mmp or
  {
    paused = false,
    autowalking = false,
    currentroom = 0,
    currentroomname = "(unknown)",
    firstRun = true,
    specials = {},
    ferry_rooms = {},
  }
speedWalkWatch = createStopWatch()
-- populated by Mudlet from getPath() and gotoRoom()
speedWalkPath = speedWalkPath or {}
speedWalkDir = speedWalkDir or {}
speedWalkCounter = 0
-- actually used by the mapper for walking
mmp.speedWalk = mmp.speedWalk or {}
mmp.speedWalkPath = mmp.speedWalkPath or {}
mmp.speedWalkDir = mmp.speedWalkDir or {}
local newversion = "19.11.3"
if mmp.version and mmp.version ~= newversion then
  if not mmp.game then
    mmp.echo(
      "Mapper script updated - Thanks! I don't know what game are you connected to, though - so please reconnect, if you could."
    )
  else
    mmp.echo("Mapper script updated - thanks! You don't need to restart.")
  end
end
mmp.version = newversion

function mmp.startup()
  if not mmp.firstRun then
    return
  end
  local private_settings = {}
  --General settings
  private_settings["echocolour"] =
    createOption(
      "cyan",
      mmp.changeEchoColour,
      {"string"},
      "Set the color for room number echos?",
      function(newSetting)
        return color_table[newSetting] ~= nil
      end
    )
  private_settings["crowdmap"] =
    createOption(
      false,
      mmp.chageMapSource,
      {"boolean"},
      "Use a crowd-sourced map instead of IREs default?",
      nil,
      {achaea = true, starmourn = true, lusternia = true}
    )
  private_settings["showcmds"] =
    createOption(true, mmp.changeBoolFunc, {"boolean"}, "Show walking commands?")
  private_settings["slowwalk"] =
    createOption(
      false, mmp.setSlowWalk, {"boolean"}, "Walk slowly instead of as quick as possible?"
    )
  private_settings["updatemap"] =
    createOption(true, mmp.changeUpdateMap, {"boolean"}, "Check for new maps from your MUD?")
  private_settings["waterwalk"] =
    createOption(
      true,
      mmp.setWaterWalk,
      {"boolean"},
      "Have waterwalk (don't avoid water)?",
      nil,
      {achaea = true}
    )
  --locking things
  private_settings["lockpathways"] =
    createOption(
      true, mmp.lockPathways, {"boolean"}, "Lock pathway exits?", nil, {lusternia = true}
    )
  private_settings["locksewers"] =
    createOption(false, mmp.lockSewers, {"boolean"}, "Lock all sewers?", nil, {achaea = true})
  private_settings["lockspecials"] =
    createOption(false, mmp.lockSpecials, {"boolean"}, "Lock all special exits?")
  private_settings["lockwormholes"] =
    createOption(
      true,
      mmp.lockWormholes,
      {"boolean"},
      "Lock all wormholes?",
      nil,
      {achaea = true, imperian = true, aetolia = true}
    )
  --Sprint movement
  private_settings["dash"] =
    createOption(
      false,
      mmp.changeBoolFunc,
      {"boolean"},
      "Use Dash?",
      nil,
      {achaea = true, imperian = true, aetolia = true}
    )
  private_settings["sprint"] = createOption(false, mmp.changeBoolFunc, {"boolean"}, "Use Sprint?")
  private_settings["gallop"] = createOption(false, mmp.changeBoolFunc, {"boolean"}, "Use Gallop?")
  private_settings["runaway"] =
    createOption(
      false, mmp.changeBoolFunc, {"boolean"}, "Use Jester Runaway?", nil, {achaea = true}
    )
  --Achaea wings and things
  private_settings["winglanguage"] =
    createOption(
      "",
      mmp.setWingsLanguage,
      {"string"},
      "Speak non-default language for wings:",
      nil,
      {achaea = true}
    )
  private_settings["pebble"] =
    createOption(
      false, mmp.lockPebble, {"boolean"}, "Make use of your enchanted pebble?", nil, {achaea = true}
    )
  private_settings["removewings"] =
    createOption(
      true,
      mmp.setWingsRemoval,
      {"boolean"},
      "Remove Wings after using them?",
      nil,
      {achaea = true, imperian = true}
    )
  private_settings["harness"] =
    createOption(
      false, mmp.setHarness, {"boolean"}, "Use Stratospheric Harness?", nil, {achaea = true}
    )
  --PapaGuacamole
  private_settings["duantahar"] =
    createOption(false, mmp.setDuantahar, {"boolean"}, "Use Chenubian Wings?", nil, {achaea = true})
  private_settings["duanatharan"] =
    createOption(false, mmp.setDuanatharan, {"boolean"}, "Use Atavian Wings?", nil, {achaea = true})
  private_settings["duanathar"] =
    createOption(false, mmp.setDuanathar, {"boolean"}, "Use Eagle Wings?", nil, {achaea = true})
  private_settings["duanatharic"] =
    createOption(false, mmp.setDuanatharic, {"boolean"}, "Use Island Wings?", nil, {achaea = true})
  private_settings["soar"] =
    createOption(false, mmp.setSoar, {"boolean"}, "Use Aero Soar?", nil, {achaea = true})
  private_settings["shackle"] =
    createOption(false, mmp.changeBoolFunc, {"boolean"}, "Take off shackle?", nil, {achaea = true})
  private_settings["universe"] =
    createOption(false, mmp.setUniverse, {"boolean"}, "Use Universe Tarot?", nil, {achaea = true})
  private_settings["gare"] =
    createOption(false, mmp.setGare, {"boolean"}, "Use Gare?", nil, {achaea = true})
  --Achaea Orb of Confinement
  private_settings["orbashtan"] =
    createOption(
      false,
      function()
        mmp.setOrb("ashtan")
      end,
      {"boolean"},
      "Orb of Confinement active in Ashtan?",
      nil,
      {achaea = true}
    )
  private_settings["orbcyrene"] =
    createOption(
      false,
      function()
        mmp.setOrb("cyrene")
      end,
      {"boolean"},
      "Orb of Confinement active in Cyrene?",
      nil,
      {achaea = true}
    )
  private_settings["orbeleusis"] =
    createOption(
      false,
      function()
        mmp.setOrb("eleusis")
      end,
      {"boolean"},
      "Orb of Confinement active in Eleusis?",
      nil,
      {achaea = true}
    )
  private_settings["orbhashan"] =
    createOption(
      false,
      function()
        mmp.setOrb("hashan")
      end,
      {"boolean"},
      "Orb of Confinement active in Hashan?",
      nil,
      {achaea = true}
    )
  private_settings["orbmhaldor"] =
    createOption(
      false,
      function()
        mmp.setOrb("mhaldor")
      end,
      {"boolean"},
      "Orb of Confinement active in Mhaldor?",
      nil,
      {achaea = true}
    )
  private_settings["orbtargossas"] =
    createOption(
      false,
      function()
        mmp.setOrb("targossas")
      end,
      {"boolean"},
      "Orb of Confinement active in Targossas?",
      nil,
      {achaea = true}
    )
  --Imperian wings
  private_settings["shekinah"] =
    createOption(false, mmp.setShekinah, {"boolean"}, "Use Seraphim Wings?", nil, {imperian = true})
  private_settings["suriel"] =
    createOption(false, mmp.setSuriel, {"boolean"}, "Use Orphanim Wings?", nil, {imperian = true})
  --Lusternia bixes
  private_settings["torus"] =
    createOption(
      false, mmp.setTorus, {"boolean"}, "Make use of your Torus?", nil, {lusternia = true}
    )
  private_settings["prism"] =
    createOption(
      false,
      mmp.setPrism,
      {"boolean"},
      "Make use of your transplanar prism?",
      nil,
      {lusternia = true}
    )
  private_settings["cubix"] =
    createOption(
      false, mmp.setCubix, {"boolean"}, "Make use of your Cubix?", nil, {lusternia = true}
    )
  private_settings["medallion"] =
    createOption(
      false, mmp.setMedallion, {"boolean"}, "Make use of your Medallion?", nil, {lusternia = true}
    )
  --Lusternia Bubblixes
  private_settings["tibia"] =
    createOption(
      false, mmp.setTibia, {"boolean"}, "Make use of your Tibia?", nil, {lusternia = true}
    )
  private_settings["mud"] =
    createOption(false, mmp.setMud, {"boolean"}, "Make use of your Mud?", nil, {lusternia = true})
  private_settings["cookie"] =
    createOption(
      false, mmp.setCookie, {"boolean"}, "Make use of your Cookie?", nil, {lusternia = true}
    )
  private_settings["icicle"] =
    createOption(
      false, mmp.setIcicle, {"boolean"}, "Make use of your Icicle?", nil, {lusternia = true}
    )
  private_settings["screwdriver"] =
    createOption(
      false,
      mmp.setScrewdriver,
      {"boolean"},
      "Make use of your Screwdriver?",
      nil,
      {lusternia = true}
    )
  private_settings["snowglobe"] =
    createOption(
      false, mmp.setSnowglobe, {"boolean"}, "Make use of your Snowglobe?", nil, {lusternia = true}
    )
  private_settings["head"] =
    createOption(
      false, mmp.setHead, {"boolean"}, "Make use of your Doll's Head?", nil, {lusternia = true}
    )
  private_settings["wheel"] =
    createOption(
      false, mmp.setWheel, {"boolean"}, "Make use of your Quartz Wheel?", nil, {lusternia = true}
    )
  --Lusternia Curio collections
  private_settings["bonecurio"] =
    createOption(
      false, mmp.setBonecurio, {"boolean"}, "Make use of your Bone curios?", nil, {lusternia = true}
    )
  private_settings["facecurio"] =
    createOption(
      false, mmp.setFacecurio, {"boolean"}, "Make use of your Face curios?", nil, {lusternia = true}
    )
  private_settings["feathercurio"] =
    createOption(
      false,
      mmp.setFeathercurio,
      {"boolean"},
      "Make use of your Feather curios?",
      nil,
      {lusternia = true}
    )
  private_settings["figurecurio"] =
    createOption(
      false,
      mmp.setFigurecurio,
      {"boolean"},
      "Make use of your Figure curios?",
      nil,
      {lusternia = true}
    )
  private_settings["flowercurio"] =
    createOption(
      false,
      mmp.setFlowercurio,
      {"boolean"},
      "Make use of your Flower curios?",
      nil,
      {lusternia = true}
    )
  private_settings["fluttercurio"] =
    createOption(
      false,
      mmp.setFluttercurio,
      {"boolean"},
      "Make use of your Flutter curios?",
      nil,
      {lusternia = true}
    )
  private_settings["toolcurio"] =
    createOption(
      false,
      mmp.setToolcurio,
      {"boolean"},
      "Make use of your Tool curios]?",
      nil,
      {lusternia = true}
    )
  private_settings["vernalcurio"] =
    createOption(
      false,
      mmp.setVernalcurio,
      {"boolean"},
      "Make use of your Vernal curios?",
      nil,
      {lusternia = true}
    )
  private_settings["utensilcurio"] =
    createOption(
      false,
      mmp.setUtensilcurio,
      {"boolean"},
      "Make use of your Utensil curios?",
      nil,
      {lusternia = true}
    )
  private_settings["toycurio"] =
    createOption(
      false, mmp.setToycurio, {"boolean"}, "Make use of your Toy curios?", nil, {lusternia = true}
    )
  private_settings["soullesscurio"] =
    createOption(
      false,
      mmp.setSoullesscurio,
      {"boolean"},
      "Make use of your Soulless curios?",
      nil,
      {lusternia = true}
    )
  --Lusternia epic
  private_settings["fingerblade"] =
    createOption(
      false,
      mmp.setFingerblade,
      {"boolean"},
      "Make use of your Fingerblade?",
      nil,
      {lusternia = true}
    )
  private_settings["blossom"] =
    createOption(
      false,
      mmp.setBlossom,
      {"boolean"},
      "Make use of your Flame of dae'Seren?",
      nil,
      {lusternia = true}
    )
  private_settings["belt"] =
    createOption(false, mmp.setBelt, {"boolean"}, "Make use of your Belt?", nil, {lusternia = true})
  private_settings["mandala"] =
    createOption(
      false, mmp.setMandala, {"boolean"}, "Make use of your Mandala?", nil, {lusternia = true}
    )
  private_settings["mantle"] =
    createOption(
      false, mmp.setMantle, {"boolean"}, "Make use of your Mantle?", nil, {lusternia = true}
    )
  private_settings["key"] =
    createOption(false, mmp.setKey, {"boolean"}, "Make use of your Key?", nil, {lusternia = true})
  --misc
  private_settings["caravan"] =
    createOption(false, mmp.changeBoolFunc, {"boolean"}, "Walk caravans?", nil, {imperian = true})
  mmp.settings = createOptionsTable(private_settings)
  mmp.settings.disp = mmp.echo
  mmp.game = false
  mmp.settings.dispOption =
    function(opt, val)
      cecho(
        "&lt;green&gt;" ..
        val.use ..
        "&lt;white&gt; (" ..
        opt ..
        ") " ..
        string.rep(" ", 50 - val.use:len() - opt:len()) ..
        tostring(val.value) ..
        "\n"
      )
    end
  mmp.settings.dispDefaultWriteError =
    function()
      mmp.echo("Please use the mconfig alias to set options!")
    end
  raiseEvent("mmp areas changed")
  mmp.firstRun = false
  mmp.echon("Mudlet Mapper script for IREs (" .. tostring(mmp.version) .. ") loaded! (")
  echoLink(
    "homepage",
    "(openUrl or openURL)'http://wiki.mudlet.org/w/IRE_mapping_script'",
    "Clicky clicky to read up on what's this about"
  )
  echo(")\n")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>speedwalking</name>
					<packageName></packageName>
					<script>function mmp.gotoRoom(where, dashtype, gotoType)
  mmp.speedWalk.type = gotoType or "room"
  if not where or not tonumber(where) then
    mmp.echo("Where do you want to go to?")
    return
  end
  if tonumber(where) == mmp.currentroom then
    mmp.echo("We're already at " .. where .. "!")
    raiseEvent("mmapper arrived")
    return
  end
  -- allow mapper 'addons' to link their own exits in
  raiseEvent("mmp link externals")
  -- if getPath worked, then the dirs and room #'s tables were populated for us
  if not mmp.getPath(mmp.currentroom, tonumber(where)) then
    mmp.echo("Don't know how to get there (" .. tostring(where) .. ") from here :(")
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    raiseEvent("mmapper failed path")
    if mmp.settings.shackle then
      expandAlias("wear shackle")
    end
    -- allow mapper 'addons' to unlink their special exits
    raiseEvent("mmp clear externals")
    return
  end
  doSpeedWalk(dashtype)
  -- allow mapper 'addons' to unlink their special exits
  raiseEvent("mmp clear externals")
end

function mmp.gotoArea(where, number, dashtype, exact)
  mmp.speedWalk.type = "area"
  if not where or type(where) ~= "string" then
    mmp.echo("Where do you want to go to?")
    return
  end
  local where = where:lower()
  number = tonumber(number)
  local tmp = getRoomUserData(1, "gotoMapping")
  if not tmp or tmp == '' then
    tmp = "[]"
  end
  local temp, maptable = yajl.to_value(tmp), {}
  for k, v in pairs(temp) do
    maptable[k:lower()] = v
  end
  local destinationRoom = maptable[where]
  if destinationRoom then
    mmp.gotoRoom(destinationRoom, dashtype)
    return
  end
  local areaid, msg, multiples = mmp.findAreaID(where, exact)
  if areaid then
    mmp.gotoAreaID(areaid)
  elseif not areaid and #multiples &gt; 0 then
    if number and number &lt;= #multiples then
      mmp.gotoArea(multiples[number], nil, dashtype, true)
      return
    end
    mmp.echo("Which area would you like to go to?")
    fg("DimGrey")
    for key, areaname in ipairs(multiples) do
      echo("  ")
      echoLink(
        key .. ") ",
        'mmp.gotoArea("' ..
        areaname ..
        '", nil, ' ..
        (dashtype and '"' .. dashtype .. '"' or "nil") ..
        ', true)',
        "Click to go to " .. areaname,
        true
      )
      setUnderline(true)
      echoLink(
        areaname,
        'mmp.gotoArea("' ..
        areaname ..
        '", nil, ' ..
        (dashtype and '"' .. dashtype .. '"' or "nil") ..
        ', true)',
        "Click to go to " .. areaname,
        true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
    return
  else
    mmp.echo(string.format("Don't know of any area named '%s'.", where))
    return
  end
end

--- DOES NOT ACCOUNT FOR CHANGING THE MAP YET (within a profile load), because we don't know when it happens
local getpathcache = {}
--setmetatable(getpathcache, {__mode = "kv"}) -- weak keys/values = it'll periodically get cleaned up by gc

function mmp.getPath(from, to)
  assert(tonumber(from) and tonumber(to), "mmp.getPath: both from and to have to be room IDs")
  local key = string.format("%s_%s", from, to)
  local resulttbl = getpathcache[key]
  -- not in cache?
  if not resulttbl then
    mmp.computeGetPath = mmp.computeGetPath or createStopWatch()
    startStopWatch(mmp.computeGetPath)
    local boolean = getPath(from, to)
    if mmp.debug then
      mmp.echo(
        "a new getPath() from " ..
        from ..
        " to " ..
        to ..
        " took " ..
        stopStopWatch(mmp.computeGetPath) ..
        "s."
      )
    end
    -- save it into the cache &amp; send away
    getpathcache[key] = {boolean, speedWalkDir, speedWalkPath}
    return boolean
  end
  -- or if it is, retrieve &amp; send away
  speedWalkDir = resulttbl[2]
  speedWalkPath = resulttbl[3]
  return resulttbl[1]
end

function mmp.clearpathcache()
  if mmp.debug then
    mmp.echo("path cache cleared")
  end
  getpathcache = {}
end

function mmp.showpathcache()
  return getpathcache
end

function mmp.setmovetimer(time)
  if mmp.movetimer then
    killTimer(mmp.movetimer)
  end
  if mmp.settings.slowwalk then
    return
  end
  mmp.movetimer =
    tempTimer(
      getNetworkLatency() + (time or 0.5),
      function()
        mmp.movetimer = false
        mmp.move()
      end
    )
end

-- moves to the next room we need to.

function mmp.move()
  if mmp.paused or not mmp.autowalking or mmp.movetimer or not mmp.canmove() then
    return
  end
  -- sometimes it's 0 - default to 1
  if speedWalkCounter == 0 then
    speedWalkCounter = 1
  end
  local cmd
  if mmp.settings["caravan"] then
    cmd = "lead caravan " .. mmp.speedWalkDir[speedWalkCounter]
  else
    cmd = mmp.speedWalkDir[speedWalkCounter]
  end
  cmd = cmd or ''
  -- timeout before loadstring, so it can set its own if it would like to.
  mmp.setmovetimer()
  if string.starts(cmd, "script:") then
    cmd = string.gsub(cmd, "script:", "")
    loadstring(cmd)()
    if mmp.settings.showcmds then
      cecho(
        string.format(
          "&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;%s&lt;red&gt;)",
          #mmp.speedWalkDir - speedWalkCounter + 1,
          "&lt;script&gt;"
        )
      )
    end
  else
    send(cmd, false)
    if mmp.settings.showcmds then
      cecho(
        string.format(
          "&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;%s&lt;red&gt;)",
          #mmp.speedWalkDir - speedWalkCounter + 1,
          cmd
        )
      )
    end
  end
end

function mmp.swim()
  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end
  send(
    "swim " ..
    mmp.speedWalkDir[speedWalkCounter]:gsub("sprint ", ""):gsub("dash ", ""):gsub("gallop ", ""):gsub(
      "runaway ", ""
    ),
    false
  )
  if mmp.settings.showcmds then
    cecho(
      string.format(
        "&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;swim %s&lt;red&gt;)",
        #mmp.speedWalkDir - speedWalkCounter + 1,
        mmp.speedWalkDir[speedWalkCounter]:gsub("sprint ", ""):gsub("dash ", ""):gsub("gallop ", ""):gsub(
          "runaway ", ""
        )
      )
    )
  end
  mmp.setmovetimer(2.5)
end

function mmp.enterGrate()
  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end
  send("enter grate " .. mmp.speedWalkDir[speedWalkCounter], false)
  if mmp.settings.showcmds then
    cecho(
      string.format(
        "&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;enter grate %s&lt;red&gt;)",
        #mmp.speedWalkDir - speedWalkCounter + 1,
        mmp.speedWalkDir[speedWalkCounter]
      )
    )
  end
  mmp.setmovetimer(2.5)
end

function mmp.openDoor()
  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end
  send(
    "open door " ..
    mmp.speedWalkDir[speedWalkCounter]:gsub("sprint ", ""):gsub("dash ", ""):gsub("gallop ", ""):gsub(
      "runaway ", ""
    ),
    false
  )
  if mmp.settings.showcmds then
    cecho(
      string.format(
        "&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;open door %s&lt;red&gt;)",
        #mmp.speedWalkDir - speedWalkCounter + 1,
        mmp.speedWalkDir[speedWalkCounter]:gsub("sprint ", ""):gsub("dash ", ""):gsub("gallop ", ""):gsub(
          "runaway ", ""
        )
      )
    )
  end
  mmp.setmovetimer(getNetworkLatency())
end

function mmp.unlockDoor()
  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end
  send(
    "unlock door " ..
    mmp.speedWalkDir[speedWalkCounter]:gsub("sprint ", ""):gsub("dash ", ""):gsub("gallop ", ""):gsub(
      "runaway ", ""
    ),
    false
  )
  if mmp.settings.showcmds then
    cecho(
      string.format(
        "&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;unlock door %s&lt;red&gt;)",
        #mmp.speedWalkDir - speedWalkCounter,
        mmp.speedWalkDir[speedWalkCounter]:gsub("sprint ", ""):gsub("dash ", ""):gsub("gallop ", ""):gsub(
          "runaway ", ""
        )
      )
    )
  end
  mmp.setmovetimer(getNetworkLatency())
end

function mmp.customwalkdelay(delay)
  mmp.setmovetimer(getNetworkLatency() + delay)
end

function mmp.stop()
  mmp.speedWalkPath = {}
  mmp.speedWalkDir = {}
  speedWalkCounter = 0
  stopStopWatch(speedWalkWatch)
  --if mmp.movetimer then killTimer( mmp.movetimer ) end
  mmp.autowalking = false
  -- clear all the temps we've got
  for trigger, ID in pairs(mmp.specials) do
    killTrigger(ID)
  end
  mmp.specials = {}
  mmp.echo("Stopped walking.")
  raiseEvent("mmapper stopped")
  if mmp.settings.shackle then
    expandAlias("wear shackle")
  end
end

-- Aetolia and Lusternia support showing balances in GMCP. This is easy to support, so we do!
-- if we can't move, setup a polling timer to prompt walking when we can again.
-- popular systems that expose balance &amp; equilibrium values can be added here as well, perhaps though a similarly-named function.

function mmp.canmove(fromtimer)
  if mapper_can_move and mapper_can_move() then
    if fromtimer then
      mmp.move()
    else
      return true
    end
  elseif mapper_can_move then
    tempTimer(0.2, [[mmp.canmove(true)]])
    return false
  end
  if not gmcp.Char then
    return true
  end
  -- Achaea
  -- Lusternia
  if
    (
      gmcp.Char and
      (not gmcp.Char.Vitals.bal or gmcp.Char.Vitals.bal == "1") and
      (not gmcp.Char.Vitals.eq or gmcp.Char.Vitals.eq == "1") and
      (not gmcp.Char.Vitals.balance or gmcp.Char.Vitals.balance == "1") and
      (not gmcp.Char.Vitals.equilibrium or gmcp.Char.Vitals.equilibrium == "1") and
      (not gmcp.Char.Vitals.right_arm or gmcp.Char.Vitals.right_arm == "1") and
      (not gmcp.Char.Vitals.left_arm or gmcp.Char.Vitals.left_arm == "1") and
      (not gmcp.Char.Vitals.right_leg or gmcp.Char.Vitals.right_leg == "1") and
      (not gmcp.Char.Vitals.left_leg or gmcp.Char.Vitals.left_leg == "1") and
      (not gmcp.Char.Vitals.psisuper or gmcp.Char.Vitals.psisuper ~= "0") and
      (not gmcp.Char.Vitals.psisub or gmcp.Char.Vitals.psisub ~= "0") and
      (not gmcp.Char.Vitals.psiid or gmcp.Char.Vitals.psiid ~= "0") and
      (not gmcp.Char.Balance or gmcp.Char.Balance.List.balance == "1") and
      (not gmcp.Char.Balance or gmcp.Char.Balance.List.equilibrium == "1") and
      (not gmcp.Char.Balance or gmcp.Char.Balance.List.rarm == "1") and
      (not gmcp.Char.Balance or gmcp.Char.Balance.List.larm == "1") and
      (not gmcp.Char.Balance or gmcp.Char.Balance.List.legs == "1") and
      (not gmcp.Char.Vitals.prone or (gmcp.Char.Vitals.prone == "0" or gmcp.Char.Vitals.prone == 0))
    )
  then
    if fromtimer then
      mmp.move()
    else
      return true
    end
  else
    tempTimer(0.2, [[mmp.canmove(true)]])
    return false
  end
end

local oldnum

function speedwalking(event, num)
  local num = tonumber(num) or tonumber(msdp.ROOM_VNUM)
  if num ~= mmp.currentroom then
    mmp.previousroom = mmp.currentroom
  end
  mmp.currentroom = num
  mmp.currentroomname = getRoomName(num)
  -- Try to track if we're flying or not, for Imperian wings
  -- This is to avoid being "off path" if we FLY due to wings.
  local madeflight = false
  --if gmcp.Room then
  --  local flying = false
  --  if string.find(gmcp.Room.Info.name, "^flying above") then
  --    flying = true
  --  end
  --  if mmp.flying and not flying then
  --    -- We were flying, and now we are not. Gravity!
  --    mmp.flying = false
  --  elseif not mmp.flying and flying then
  --    -- We were not flying and now we are.
  --    madeflight = true
  --    mmp.flying = true
  --  elseif not flying then
  --    mmp.flying = false
  --  end
  --else
    mmp.flying = false
  --end
  -- track if we're inside or outside, if possible
  if msdp.SECTOR then
    local areaID = getRoomArea(mmp.currentroom)
    if
      mmp.inside and
      not (
        tostring(msdp.SECTOR) == "inside" or
        tostring(msdp.SECTOR) == "cave"
        --table.contains(gmcp.Room.Info.details, "indoors") or
        --table.contains(gmcp.Room.Info.details, "considered indoors")
      ) and
      not mmp.orbed()
    then
      mmp.inside = false
      raiseEvent("mmapper went outside")
    elseif
      not mmp.inside and
      (
        tostring(msdp.SECTOR) == "inside" or
        tostring(msdp.SECTOR) == "cave"
        --table.contains(gmcp.Room.Info.details, "indoors") or
        --table.contains(gmcp.Room.Info.details, "considered indoors") or
        --mmp.orbed()
      )
    then
      mmp.inside = true
      raiseEvent("mmapper went inside")
    end
    if
      #table.n_union(
        mmp.getareacontinents(getRoomArea(mmp.previousroom)),
        mmp.getareacontinents(getRoomArea(num))
      ) ~= #mmp.getareacontinents(getRoomArea(num))
    then
      raiseEvent("mmapper changed continent")
    end
    -- the event could cancel speedwalking - in this case quit
    if mmp.ignore_speedwalking then
      mmp.ignore_speedwalking = nil
      return
    end
  end
  if oldnum == num then
    return
  else
    oldnum = num
  end
  if not mmp.autowalking then
    return
  end
  if mmp.movetimer then
    killTimer(mmp.movetimer)
    mmp.movetimer = false
  end
  if num == mmp.speedWalkPath[#mmp.speedWalkPath] then
    local walktime = stopStopWatch(speedWalkWatch)
    mmp.echo(string.format("We've arrived! Took us %.1fs.\n", walktime))
    raiseEvent("mmapper arrived")
    if mmp.settings.shackle then
      expandAlias("wear shackle")
    end
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    mmp.autowalking = false
  elseif mmp.speedWalkPath[speedWalkCounter] == num then
    speedWalkCounter = speedWalkCounter + 1
    mmp.move()
  elseif mmp.game == "imperian" and madeflight then
    mmp.echo("We began flying!")
    mmp.move()
  elseif
    #mmp.speedWalkPath &gt; 0 and
    not mmp.ferry_rooms[num] and
    not (msdp.ROOM_NAME and tostring(msdp.AREA_NAME) == "ferry")
  then
    -- ended up somewhere we didn't want to be, and this isn't a ferry room?
    speedWalkMoved = false
    -- re-calculate path then
    mmp.echo("Ended up off the path, recalculating a new path...")
    local destination = mmp.speedWalkPath[#mmp.speedWalkPath]
    if not mmp.getPath(num, destination) then
      mmp.echo(
        string.format(
          "Don't know how to get to %d (%s) anymore :( Move into a room we know of to continue",
          destination,
          getRoomName(destination)
        )
      )
    else
      mmp.gotoRoom(destination)
    end
  end
end

function doSpeedWalk(dashtype)
  mmp.speedWalkDir = mmp.deepcopy(speedWalkDir)
  mmp.speedWalkPath = mmp.deepcopy(speedWalkPath)
  speedWalkDir, speedWalkPath = {}, {}
  resetStopWatch(speedWalkWatch)
  startStopWatch(speedWalkWatch)
  if
    mmp.settings["gallop"] or
    mmp.settings["dash"] or
    mmp.settings.sprint or
    mmp.settings.runaway or
    dashtype
  then
    mmp.fixPath(
      mmp.currentroom,
      mmp.speedWalkPath[#mmp.speedWalkPath],
      (mmp.settings["gallop"] and "gallop") or
      (mmp.settings["dash"] and "dash") or
      (mmp.settings.sprint and "sprint") or
      (mmp.settings.runaway and "runaway") or
      dashtype
    )
  end
  mmp.fixSpecialExits(mmp.speedWalkDir)
  if #mmp.speedWalkPath == 0 then
    mmp.autowalking = false
    mmp.echo("Couldn't find a path to the destination :(")
    raiseEvent("mmapper failed path")
    if mmp.settings.shackle then
      expandAlias("wear shackle")
    end
    return
  end
  -- this is a fix: convert nums to actual numbers
  for i = 1, #mmp.speedWalkPath do
    mmp.speedWalkPath[i] = tonumber(mmp.speedWalkPath[i])
  end
  mmp.autowalking = true
  raiseEvent("s")
  if mmp.settings.shackle then
    expandAlias("remove shackle")
  end
  if not mmp.paused then
    --mmp.echon("Starting speedwalk from " .. (atcp.RoomNum or gmcp.Room.Info.num or tonumber(msdp.ROOM_VNUM)) .. " to ")
    mmp.echon("Starting speedwalk from " .. (msdp.ROOM_VNUM) .. " to ")
    cechoLink(
      "&lt;" .. mmp.settings.echocolour .. "&gt;" .. mmp.speedWalkPath[#mmp.speedWalkPath],
      'mmp.gotoRoom "' .. mmp.speedWalkPath[#mmp.speedWalkPath] .. '"',
      'Go to ' .. mmp.speedWalkPath[#mmp.speedWalkPath],
      true
    )
    echo(": ")
    speedWalkCounter = 1
    if mmp.canmove() then
      mmp.move()
    else
      echo("(when we get balance back / aren't hindered)")
    end
  else
    mmp.echo(
      "Will go to " ..
      mmp.speedWalkPath[#mmp.speedWalkPath] ..
      " as soon as the mapper is unpaused."
    )
  end
end

function mmp.failpath()
  if mmp.movetimer then
    local walktime = stopStopWatch(speedWalkWatch)
    mmp.echo(string.format("Can't continue further! Took us %.1fs to get here.\n", walktime))
  end
  mmp.autowalking = false
  if mmp.settings.shackle then
    expandAlias("wear shackle")
  end
  mmp.speedWalkPath = {}
  mmp.speedWalkDir = {}
  speedWalkCounter = 0
  if mmp.movetimer then
    killTimer(mmp.movetimer)
    mmp.movetimer = nil
  end
  raiseEvent("mmapper failed path")
end

function mmp.changeBoolFunc(name, option)
  local en
  en = option and "will now use" or "will no longer use"
  mmp.echo("&lt;green&gt;Okay, the mapper " .. en .. " &lt;white&gt;" .. name .. "&lt;green&gt;!")
end

function mmp.fixPath(rFrom, rTo, dashtype)
  local currentPath, currentIds = {}, {}
  local dRef = {["n"] = "north", ["e"] = "east", ["s"] = "south", ["w"] = "west"}
  if not getPath(rFrom, rTo) then
    return false
  end
  -- Logic: Look for a direction repeated at least two times.
  -- count the number of times it repeats, then look that many rooms ahead.
  -- if that room also contains the direction we're headed, just travel that many directions.
  -- otherwise, dash.
  local repCount = 1
  local index = 1
  local dashExaust = false
  while mmp.speedWalkDir[index] do
    if not table.contains(getSpecialExits(mmp.speedWalkPath[index]), mmp.speedWalkDir[index]) then
      dashExaust = false
      repCount = 1
      while mmp.speedWalkDir[index + repCount] == mmp.speedWalkDir[index] do
        repCount = repCount + 1
        if repCount == 11 then
          dashExaust = true
          break
        end
      end
      if repCount &gt; 1 then
        -- Found direction repitition. Calculate dash path.
        local exits = getRoomExits(mmp.speedWalkPath[index + (repCount - 1)])
        local pname = ""
        for word in mmp.speedWalkDir[index]:gmatch("%w") do
          pname = pname .. (dRef[word] or word)
        end
        if not exits[pname] or dashExaust then
          -- Final room in this direction does not continue, dash!
          table.insert(currentPath, string.format("%s %s", dashtype, mmp.speedWalkDir[index]))
          currentIds[#currentIds + 1] = mmp.speedWalkPath[index + repCount - 1]
        else
          -- Final room in this direction continues onwards, don't dash unless on achaea
          if mmp.game == "achaea" then
            table.insert(
              currentPath, string.format("%s %s %s", dashtype, mmp.speedWalkDir[index], repCount)
            )
            currentIds[#currentIds + 1] = mmp.speedWalkPath[index + repCount - 1]
          else
            for i = 1, repCount do
              table.insert(currentPath, mmp.speedWalkDir[index])
              currentIds[#currentIds + 1] = mmp.speedWalkPath[index + i - 1]
            end
          end
        end
        index = index + repCount
      else
        -- No repetition, just add the direction.
        table.insert(currentPath, mmp.speedWalkDir[index])
        currentIds[#currentIds + 1] = mmp.speedWalkPath[index]
        index = index + 1
      end
    else
      -- Special exit, skip over this step
      table.insert(currentPath, mmp.speedWalkDir[index])
      currentIds[#currentIds + 1] = mmp.speedWalkPath[index]
      index = index + 1
    end
  end
  mmp.speedWalkDir = currentPath
  mmp.speedWalkPath = currentIds
  return true
end

-- a certain version of the mapper gave us special exits prepended with 0 or 1 in the command
-- depending on if it was locked. Need to remove these before we can use them

function mmp.fixSpecialExits(directions)
  for i = 1, #directions do
    if directions[i]:match("^%d") then
      directions[i] = directions[i]:sub(2)
    end
  end
end

-- cleanup function to remove the temp special exit we made

function mmp.clearspecials(deleterooms)
  local t = getSpecialExits(mmp.currentroom)
  for connectingroom, exits in pairs(t) do
    if table.contains(deleterooms, connectingroom) then
      -- delete the special exits linking to this room
      for command, locked in pairs(exits) do
        removeSpecialExit(mmp.currentroom, command)
      end
    end
  end
end

local function getShortestOfMultipleRooms(possibleRooms)
  local shortestPath, closestRoom = {}, 0
  mmp.computeShortestWatch = mmp.computeShortestWatch or createStopWatch()
  startStopWatch(mmp.computeShortestWatch)
  raiseEvent("mmp link externals")
  local getStopWatchTime, tonumber, getPath = getStopWatchTime, tonumber, mmp.getPath
  --mmp.echo(string.format("Have %s rooms nodes, %ss taken so far...", table.size(possibleRooms), getStopWatchTime(mmp.computeShortestWatch)))
  -- allocate only 500ms to finding the shortest path, or more if we failed to find anything
  local checkedsofar, outoftime = 0
  for id, _ in pairs(possibleRooms) do
    if mmp.getPath(mmp.currentroom, tonumber(id)) then
      if closestRoom == 0 or #shortestPath &gt; #speedWalkPath then
        shortestPath = speedWalkPath
        closestRoom = tonumber(id)
      end
    end
    checkedsofar = checkedsofar + 1
    if (getStopWatchTime(mmp.computeShortestWatch) &gt;= .5) then
      outoftime = true
      break
    end
    -- mmp.echo(string.format("pathed from %s to %s, running time so far: %s", mmp.currentroom, id, getStopWatchTime(mmp.computeShortestWatch)))
  end
  --mmp.echo(string.format("total time took: %s", getStopWatchTime(mmp.computeShortestWatch)))
  stopStopWatch(mmp.computeShortestWatch)
  return closestRoom, outoftime, checkedsofar
end

function mmp.gotoAreaID(areaid, number, dashtype)
  if not areaid or not tonumber(areaid) then
    mmp.echo("To where do you want to go?")
    return
  end
  areaid = tonumber(areaid)
  if not mmp.areatabler[areaid] then
    mmp.echo("Invalid area ID selected")
    return
  end
  local possibleRooms, shortestBorder = {}, 0
  possibleRooms = mmp.getAreaBorders(areaid)
  shortestBorder, outoftime, checkedsofar = getShortestOfMultipleRooms(possibleRooms)
  if shortestBorder == 0 then
    if outoftime then
      mmp.echo(
        string.format(
          "I checked %d of the %d possible exits \"%s\" has, but none of the ways there worked and it was taking too long :( try doing this again?",
          checkedsofar,
          table.size(possibleRooms),
          getRoomAreaName(areaid)
        )
      )
    else
      mmp.echo(
        "Checked " ..
        table.size(possibleRooms) ..
        " exits in that area, and none of them worked :( I Don't know how to get you there."
      )
    end
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    raiseEvent("mmapper failed path")
    raiseEvent("mmp clear externals")
    return
  end
  raiseEvent("mmp clear externals")
  mmp.gotoRoom(shortestBorder, dashtype, "area")
end

function mmp.gotoFeature(partialFeatureName, dashtype)
  local mapFeatures = mmp.getMapFeatures()
  local feature
  if mapFeatures[partialFeatureName:lower()] then
    feature = partialFeatureName:lower()
  else
    for key in pairs(mapFeatures) do
      if key:find(partialFeatureName:lower()) then
        feature = key
        break
      end
    end
  end
  if not feature then
    mmp.echo("No feature like " .. partialFeatureName .. " found.")
    return
  end
  local rooms = searchRoomUserData("feature-" .. feature, "true")
  -- change the structure of the table so it fits getShortestOfMultipleRooms
  local possibleRooms = {}
  for _, room in pairs(rooms) do
    possibleRooms[room] = true
  end
  closestFeature, outoftime, checkedsofar = getShortestOfMultipleRooms(possibleRooms)
  if closestFeature == 0 then
    if outoftime then
      mmp.echo(
        string.format(
          "I checked %d of the %d possible features \"%s\" has, but none of the ways there worked and it was taking too long :( try doing this again?",
          checkedsofar,
          table.size(possibleRooms),
          partialFeatureName
        )
      )
    else
      mmp.echo(
        "Checked " ..
        table.size(possibleRooms) ..
        " rooms with that feature, and none of them worked :( I Don't know how to get you there."
      )
    end
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    raiseEvent("mmapper failed path")
    raiseEvent("mmp clear externals")
    return
  end
  raiseEvent("mmp clear externals")
  mmp.gotoRoom(closestFeature, dashtype, "area")
end</script>
					<eventHandlerList>
						<string>RoomNum</string>
						<string>gmcp.Room.Info</string>
						<string>msdp.ROOM_VNUM</string>
					</eventHandlerList>
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Wings and other fast travel</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Wings functions</name>
						<packageName></packageName>
						<script>local exitsCreated = exitsCreated or {}

function mmp.tempSpecialExit(start, destination, command, weight)
  if type(destination) == "string" then
    -- no start room given, so shift all arguments one to the right
    start, destination, command, weight = mmp.currentroom, start, destination, command
  end
  table.insert(exitsCreated, {room = start, command = command})
  addSpecialExit(start, destination, command)
  if weight then
    setExitWeight(start, command, weight)
  end
end

function mmp.removeWings()
  --remove all special exits that were created by addWings, then resets the table.
  for _, exit in ipairs(exitsCreated) do
    removeSpecialExit(exit.room, exit.command)
  end
  exitsCreated = {}
end

registerAnonymousEventHandler("mmp clear externals", "mmp.removeWings")</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Achaea</name>
						<packageName></packageName>
						<script>registerAnonymousEventHandler("mmp link externals", "mmp.addWingsAchaea")

function mmp.orbed()
	-- orb of confinement - PapaGuacamole
  local areaID = getRoomArea(mmp.currentroom)
  return
		(mmp.game == "achaea" and
  		(
    		(mmp.settings.orbashtan and areaID == 49) or
    		(mmp.settings.orbcyrene and areaID == 57) or
    		(mmp.settings.orbeleusis and areaID == 51) or
    		(mmp.settings.orbhashan and areaID == 55) or
    		(mmp.settings.orbmhaldor and areaID == 44) or
    		(
    			mmp.settings.orbtargossas and
    			((mmp.settings.crowdmap and areaID == 368) or (not mmp.settings.crowdmap and areaID == 271))
    		)
  		)
		)
end

function mmp.addWingsAchaea()
  --Trimmed down version of the original function, meant to only be used for wings. (Where the command varies based on several MCONFIGS)

  local function getcmd(word)
    return
      mmp.settings.removewings and
      string.format(
        [[script:sendAll("wear wings", "say *%s %s", "remove wings", false)]],
        (mmp.settings.winglanguage and mmp.settings.winglanguage or ""),
        word
      ) or
      string.format(
        [[script:send("say *%s %s", false)]],
        (mmp.settings.winglanguage and mmp.settings.winglanguage or ""),
        word
      )
  end
  --creates a special exit from your current room to a destination, and adds it to a table so it can be easily cleared later.
  --Achaea stuff!
  if mmp.game ~= "achaea" then
    return
  end
  --WINGS!
  if
    (mmp.settings.duanathar or mmp.settings.duanatharan or mmp.settings.duantahar) and
    gmcp.Room and
    not table.contains(gmcp.Room.Info.details, "indoors") and
    not mmp.orbed()
  then
    --Sarapis wings.
    if mmp.oncontinent(getRoomArea(mmp.currentroom), "Main") then
      if mmp.settings.duanatharan then
        mmp.tempSpecialExit(4882, getcmd("duanatharan"))
        mmp.tempSpecialExit(3885, getcmd("duanathar"))
      elseif mmp.settings.duantahar then
        mmp.tempSpecialExit(42319, getcmd("duanathar"))
        mmp.tempSpecialExit(4882, getcmd("duanatharan"))
      else
        mmp.tempSpecialExit(3885, getcmd("duanathar"))
      end
      --Meropis Wings
    elseif mmp.oncontinent(getRoomArea(mmp.currentroom), "Meropis") then
      if mmp.settings.duanatharan then
        mmp.tempSpecialExit(51603, getcmd("duanatharan"))
        mmp.tempSpecialExit(51188, getcmd("duanathar"))
      elseif mmp.settings.duantahar then
        mmp.tempSpecialExit(42319, getcmd("duanathar"))
        mmp.tempSpecialExit(51603, getcmd("duanatharan"))
      else
        mmp.tempSpecialExit(51188, getcmd("duanathar"))
      end
    end
    if
      mmp.settings.duanatharic and
      gmcp.Room and
      not table.contains(gmcp.Room.Info.details, "indoors") and
      not mmp.orbed()
    then
      --Island wings.
      if
        mmp.oncontinent(getRoomArea(mmp.currentroom), "Main") or
        mmp.oncontinent(getRoomArea(mmp.currentroom), "Arcadia") or
        mmp.oncontinent(getRoomArea(mmp.currentroom), "Outer") or
        mmp.oncontinent(getRoomArea(mmp.currentroom), "Meropis") or
        mmp.oncontinent(getRoomArea(mmp.currentroom), "Island") or
        mmp.oncontinent(getRoomArea(mmp.currentroom), "North")
      then
        mmp.tempSpecialExit(47571, getcmd("duanatharic"))
      end
    end
  end
  -- Stratospheric Harness support -- PapaGuacamole
  if
    mmp.settings.harness and gmcp.Room and not table.contains(gmcp.Room.Info.details, "indoors")
  then
    -- eastern isles
    if mmp.oncontinent(getRoomArea(mmp.currentroom), "Eastern_Isles") then
      mmp.tempSpecialExit(54231, "Shake Harness")
      -- northern isles
    elseif mmp.oncontinent(getRoomArea(mmp.currentroom), "Northen_Isles") then
      mmp.tempSpecialExit(48719, "Shake Harness")
      -- western isles
    elseif mmp.oncontinent(getRoomArea(mmp.currentroom), "Western_Isles") then
      mmp.tempSpecialExit(54632, "Shake Harness")
    end
  end
  -- Air Elemental Aero Soar
  if
    mmp.settings.soar and
    gmcp.Room and
    not table.contains(gmcp.Room.Info.details, "indoors") and
    not mmp.orbed()
  then
    --Sarapis soar.
    if mmp.oncontinent(getRoomArea(mmp.currentroom), "Main") then
      if
        gmcp.Char.Status.class == "air Elemental Lord" or
        gmcp.Char.Status.class == "air Elemental Lady"
      then
        mmp.tempSpecialExit(4882, "aero soar high", 10)
        -- duanatharan
        mmp.tempSpecialExit(3885, "aero soar low", 10)
        -- duanathar
        mmp.tempSpecialExit(54173, "aero soar stratosphere", 10)
        -- Stratosphere!
      end
      --Meropis soar
    elseif mmp.oncontinent(getRoomArea(mmp.currentroom), "Meropis") then
      if
        gmcp.Char.Status.class == "air Elemental Lord" or
        gmcp.Char.Status.class == "air Elemental Lady"
      then
        mmp.tempSpecialExit(51603, "aero soar high", 10)
        -- duanatharan
        mmp.tempSpecialExit(51188, "aero soar low", 10)
        -- duanathar
        mmp.tempSpecialExit(54173, "aero soar stratosphere", 10)
        -- Stratosphere!
      end
    end
  end
  --universe tarot
  if mmp.settings.universe and mmp.oncontinent(getRoomArea(mmp.currentroom), "Main") then
    local tarotLocations =
      {
        azdun = 1772,
        blackrock = 10573,
        bitterfork = 25093,
        genji = 10091,
        manusha = 8730,
        newthera = 20386,
        caerwitrin = 17678,
        shastaan = 2855,
        mannaseh = 1745,
        manara = 9124,
        brasslantern = 30383,
        mhojave = 39103,
        thraasi = 35703,
        newhope = 25581,
      }
    for village, roomnum in pairs(tarotLocations) do
      mmp.tempSpecialExit(
        roomnum,
        [=[script:
        mmp.customwalkdelay(4.5)
        send("fling universe at ground",false)
        tempTimer(4,[[send("touch ]=] ..
        village ..
        [=[",false)]])
        ]=],
        10
      )
    end
  end
  --gare
  if mmp.settings.gare and gmcp.Char and string.match(gmcp.Char.Status.race, "Dragon") then
    if
      mmp.oncontinent(getRoomArea(mmp.currentroom), "Main") or
      mmp.oncontinent(getRoomArea(mmp.currentroom), "Meropis") or
      mmp.oncontinent(getRoomArea(mmp.currentroom), "Island") or
      mmp.oncontinent(getRoomArea(mmp.currentroom), "North") or
      mmp.oncontinent(getRoomArea(mmp.currentroom), "Arcadia")
    then
      mmp.tempSpecialExit(
        12695,
        [=[script:
        mmp.customwalkdelay(4.5)
        send("pierce the veil",false)
        ]=],
        20
      )
    end
  end
  --clears the path cache so it calculates a new route.
  mmp.clearpathcache()
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Lusternia</name>
						<packageName></packageName>
						<script>registerAnonymousEventHandler("mmp link externals", "mmp.addWingsLusternia")

local function linkBubblix(area, entranceRoom, command)
  -- always add this link to allow pathfinding to the bubble regardless of indoor/outdoor
  mmp.tempSpecialExit(148, entranceRoom, command)
  -- always add this link to allow pathfinding from the bubbe regardless of indoor/outdoor
  mmp.tempSpecialExit(entranceRoom, 6831, command)
  if mmp.usebubblix() then
    if not table.contains(gmcp.Room.Info.details, "an Aetherbubble") then
      -- we are not in an Aetherbubble and could use a bubblix, so allow its use from here
      mmp.tempSpecialExit(entranceRoom, command)
    elseif gmcp.Room.Info.area == area then
      -- we are in an Aetherbubble and it's the one the bubblix belongs to and we could use a bubblix, so allow its use from here
      mmp.tempSpecialExit(6831, command)
    end
  end
end

function mmp.addWingsLusternia()
  if mmp.game ~= "lusternia" then
    return
  end
  --that dorky prism
  if mmp.useprism() then
    if mmp.settings.prism then
      mmp.tempSpecialExit(6182, "touch prism")
    end
  end
  --items that use standard bix rules
  if mmp.usebix() then
    --cubix and things
    if mmp.settings.medallion then
      mmp.tempSpecialExit(13367, "touch medallion")
    end
    if mmp.settings.cubix then
      mmp.tempSpecialExit(6184, "touch cubix")
    end
    if mmp.settings.torus and mmp.usebix() then
      mmp.tempSpecialExit(28548, "touch torus")
    end
    --epic quest items
    if mmp.settings.fingerblade then
      mmp.tempSpecialExit(18777, "touch fingerblade")
    end
    if mmp.settings.blossom then
      mmp.tempSpecialExit(18730, "touch blossom")
    end
    if mmp.settings.mandala then
      mmp.tempSpecialExit(19563, "touch mandala")
    end
    if mmp.settings.belt then
      mmp.tempSpecialExit(19627, "touch enlightened")
    end
    if mmp.settings.mantle then
      mmp.tempSpecialExit(18762, "touch starlight")
    end
    if mmp.settings.key then
      mmp.tempSpecialExit(18732, "touch key")
    end
    --curio collections!
    if mmp.settings.bonecurio then
      mmp.tempSpecialExit(28613, "curio collection activate bone")
    end
    if mmp.settings.flowercurio then
      mmp.tempSpecialExit(28624, "curio collection activate flower")
    end
    if mmp.settings.utensilcurio then
      mmp.tempSpecialExit(28617, "curio collection activate utensil")
    end
    if mmp.settings.fluttercurio then
      mmp.tempSpecialExit(28622, "curio collection activate flutter")
    end
    if mmp.settings.toolcurio then
      mmp.tempSpecialExit(28586, "curio collection activate tool")
    end
    if mmp.settings.facecurio then
      mmp.tempSpecialExit(28433, "curio collection activate face")
    end
    if mmp.settings.toycurio then
      mmp.tempSpecialExit(21548, "curio collection activate toy")
    end
    if mmp.settings.feathercurio then
      mmp.tempSpecialExit(28591, "curio collection activate feather")
    end
    if mmp.settings.figurecurio then
      mmp.tempSpecialExit(28312, "curio collection activate figure")
    end
    if mmp.settings.vernalcurio then
      mmp.tempSpecialExit(29908, "curio collection activate vernal")
    end
    if mmp.settings.soullesscurio then
      mmp.tempSpecialExit(29909, "curio collection activate soulless")
    end
  end
  --all the bubblixes!
  if mmp.settings.screwdriver then
    linkBubblix("the Facility", 10185, "touch screwdriver")
  end
  if mmp.settings.wheel then
    linkBubblix("the Dramube Triangle", 10509, "touch wheel")
  end
  if mmp.settings.mud then
    linkBubblix("Mucklemarsh", 9985, "touch mud")
  end
  if mmp.settings.snowglobe then
    linkBubblix("the Great Spirit Tree", 10992, "shake snowglobe")
  end
  if mmp.settings.cookie then
    linkBubblix("Crumkindivia", 9888, "touch cookie")
  end
  if mmp.settings.head then
    linkBubblix("the Bubble of Bottledowns", 11811, "touch doll")
  end
  if mmp.settings.icicle then
    linkBubblix("Frosticia", 10457, "touch icicle")
  end
  if mmp.settings.tibia then
    linkBubblix("the Cankermore Battlegrounds", 11600, "touch tibia")
  end
  mmp.clearpathcache()
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Imperian</name>
						<packageName></packageName>
						<script>registerAnonymousEventHandler("mmp link externals", "mmp.addWingsImperian")
mmp.imperian = mmp.imperian or {}

function mmp.addWingsImperian()
  local function getcmd(word)
    return
      mmp.settings.removewings and
      [[script:if mmp.flying then sendAll("queue eqbal wear wings","queue eqbal say ]] ..
      word ..
      [[","queue eqbal remove wings",false) else sendAll("wear wings","fly",false) end]] or
      [[script:if mmp.flying then sendAll("queue eqbal say ]] ..
      word ..
      [[",false) else sendAll("fly",false) end]]
  end

  if
    (mmp.settings.shekinah or mmp.settings.suriel) and
    gmcp.Room and
    not table.contains(gmcp.Room.Info.details, "indoors") and
    not table.contains(gmcp.Room.Info.details, "considered indoors") and
    table.contains(mmp.imperian.wingAbleAreas, getRoomArea(mmp.currentroom))
  then
    if mmp.settings.shekinah then
      -- Seraphim wings - "Say shekinah"
      local weight = 15
      if mmp.flying then
        weight = 1
      end
      mmp.tempSpecialExit(4882, getcmd("shekinah"), weight)
    elseif mmp.settings.suriel then
      -- Using Orphanim wings, SURIEL works, takes you to 3885
      local weight = 15
      if mmp.flying == "1" then
        weight = 1
      end
      mmp.tempSpecialExit(3885, getcmd("suriel"), weight)
      -- clear cache so mmp.getPath accounts for the new way
    end
  end
  mmp.clearpathcache()
end

mmp.imperian.wingAbleAreas =
  {
    45,
    35,
    15,
    56,
    101,
    123,
    36,
    110,
    18,
    75,
    172,
    9,
    66,
    148,
    113,
    175,
    188,
    244,
    88,
    171,
    118,
    295,
    167,
    25,
    139,
    70,
    132,
    28,
    135,
    174,
    8,
    275,
    107,
    53,
    112,
    185,
    158,
    164,
    299,
    74,
    351,
    16,
    63,
    269,
    77,
    85,
    142,
    328,
    318,
    46,
    95,
    17,
    329,
    33,
    96,
    82,
    47,
    144,
    121,
    3,
    68,
    51,
    134,
    1,
    319,
    11,
    19,
    129,
    146,
    65,
    324,
    325,
    125,
    191,
    163,
    30,
    54,
    292,
    290,
    7,
    136,
    267,
    335,
    102,
    43,
    89,
    20,
    169,
    49,
    147,
    196,
    301,
    252,
    99,
    145,
    195,
    130,
    42,
    270,
    166,
    128,
    168,
    34,
    223,
    170,
    22,
    27,
    138,
    115,
    337,
    44,
    6,
    161,
    32,
    92,
    83,
    294,
    104,
    69,
    23,
    155,
    350,
    48,
    57,
    150,
    97,
    341,
    105,
    340,
    5,
    194,
    338,
    327,
    271,
    323,
    322,
    79,
    122,
    62,
    131,
    176,
    133,
    310,
    307,
    120,
    137,
    13,
    76,
    160,
    60,
    304,
    94,
    306,
    303,
    81,
    291,
    276,
    302,
    149,
    297,
    179,
    272,
    41,
    293,
    289,
    91,
    159,
    71,
    157,
    298,
    266,
    208,
    109,
    80,
    14,
    2,
    186,
    12,
    178,
    52,
    124,
    274,
    141,
    343,
    177,
    67,
    103,
    111,
    72,
    268,
    87,
    117,
    21,
    353,
    253,
    93,
    308,
    40,
    248,
    243,
    4,
    153,
    212,
    116,
    84,
    197,
    61,
    78,
    184,
    173,
    31,
    98,
    114,
    162,
    50,
    37,
    140,
    73,
    127,
    156,
    90,
    100,
    143,
    309,
    126,
  }</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Utilities</name>
					<packageName></packageName>
					<script>-- functions internal to the mapper

function mmp.highlight_unfinished_rooms()
	if not mmp.areatable then return end
	for a,b in pairs (mmp.areatable) do
		local roomList = getAreaRooms(b) or {}
		for c,d in pairs (roomList) do
			if (getRoomName(d) == "") then
				local fgr,fgg,fgb = unpack(color_table.red)
				local bgr,bgg,bgb = unpack(color_table.blue)
				highlightRoom(d, fgr,fgg,fgb,bgr,bgg,bgb, 1, 100, 100)
			end
		end
	end
end

function mmp.usebix()
	if mmp.game ~= "lusternia" then return end

	if (table.contains(gmcp.Room.Info.details, "the Prime Material Plane") or
		table.contains(gmcp.Room.Info.details, "the Ethereal Plane") or
		table.contains(gmcp.Room.Info.details, "the Water Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "the Air Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "the Fire Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "the Earth Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "Celestia, Plane of Light") or
		table.contains(gmcp.Room.Info.details, "the Tainted Plane of Nil") or
		table.contains(gmcp.Room.Info.details, "the Cosmic Plane of Continuum") or
		table.contains(gmcp.Room.Info.details, "the Cosmic Plane of Vortex") or
		table.contains(gmcp.Room.Info.details, "the Astral Plane")) and
        gmcp.Room.Info.area ~= "the City of Climanti" and
		table.contains(gmcp.Room.Info.details, "outdoors") then
		return true
	end
	return false
end

function mmp.useprism()
	if mmp.game ~= "lusternia" then return end
	if (table.contains(gmcp.Room.Info.details, "the Prime Material Plane") or
	table.contains(gmcp.Room.Info.details, "the Ethereal Plane") or
	table.contains(gmcp.Room.Info.details, "the Water Elemental Plane") or
	table.contains(gmcp.Room.Info.details, "the Air Elemental Plane") or
	table.contains(gmcp.Room.Info.details, "the Fire Elemental Plane") or
	table.contains(gmcp.Room.Info.details, "the Earth Elemental Plane")) and
    gmcp.Room.Info.area ~= "the City of Climanti" and
	table.contains(gmcp.Room.Info.details, "outdoors") then
		return true
	end
	return false
end
function mmp.usebubblix()
	if mmp.game ~= "lusternia" then return end

	if ((table.contains(gmcp.Room.Info.details, "the Prime Material Plane") or
		table.contains(gmcp.Room.Info.details, "the Ethereal Plane") or
		table.contains(gmcp.Room.Info.details, "the Water Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "the Air Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "the Fire Elemental Plane") or
		table.contains(gmcp.Room.Info.details, "the Earth Elemental Plane")) and
        gmcp.Room.Info.area ~= "the City of Climanti" and
		table.contains(gmcp.Room.Info.details, "outdoors")) or
		table.contains(gmcp.Room.Info.details, "an Aetherbubble") then
		return true
	end
	return false
end</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Locating &amp; echoing functions</name>
						<packageName></packageName>
						<script>local function filterRooms(rooms, area)
  local unassignedRooms = {}
  local areaRooms = {}
  for roomnum, roomname in pairs(rooms) do
    local roomarea = getRoomUserData(roomnum, "Game Area")
    if roomarea == "" then
      unassignedRooms[roomnum] = roomname
    elseif roomarea == area then
      areaRooms[roomnum] = roomname
    end
  end
  return next(areaRooms) and areaRooms or unassignedRooms
end

-- for a given room name, we'll echo all the vnums

function mmp.echonums(roomname, area)
  local t = mmp.searchRoomExact(roomname)
  if area then
    t = filterRooms(t, area)
  end
  if not next(t) then
    echo("?")
    return nil
  end
  -- transform the kv table into a table of tables for cleaner code.
  -- + perhaps Mudlet in future will give this us anyway, sorted by relevancy
  local dt = {}
  for roomid, room in pairs(t) do
    dt[#dt + 1] = {name = room, id = roomid}
  end
  -- we can have nothing if we asked for exact match
  if not dt[1] then
    echo("?---")
    return
  end
  -- display first three ids. Can't really nicely table.concat them.
  cechoLink(
    "&lt;" .. mmp.settings.echocolour .. "&gt;" .. dt[1].id,
    'mmp.gotoRoom(' .. dt[1].id .. ')',
    string.format("Go to %s (%s)", dt[1].id, dt[1].name),
    true
  )
  if not dt[2] then
    return
  end
  echo(", ")
  cechoLink(
    "&lt;" .. mmp.settings.echocolour .. "&gt;" .. dt[2].id,
    'mmp.gotoRoom(' .. dt[2].id .. ')',
    string.format("Go to %s (%s)", dt[2].id, dt[2].name),
    true
  )
  if not dt[3] then
    return
  end
  echo(", ")
  cechoLink(
    "&lt;" .. mmp.settings.echocolour .. "&gt;" .. dt[3].id,
    'mmp.gotoRoom(' .. dt[3].id .. ')',
    string.format("Go to %s (%s)", dt[3].id, dt[3].name),
    true
  )
  if not dt[4] then
    return
  end
  echo(", ...")
end

function mmp.roomEcho(query)
  local result = mmp.searchRoom(query)
  if not tonumber(select(2, next(result))) then
    for roomid, roomname in pairs(result) do
      roomid = tonumber(roomid)
      cecho("&lt;DarkSlateGrey&gt; (")
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho("&lt;DarkSlateGrey&gt;)")
    end
  else
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho("&lt;DarkSlateGrey&gt; (")
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho("&lt;DarkSlateGrey&gt;)")
    end
  end
end

function mmp.locateAndEcho(room, person, area)
  local t = mmp.searchRoomExact(room)
  if area then
    t = filterRooms(t, area)
  end
  echo("  (")
  mmp.echonums(room, area)
  echo(")")
  -- lowercase results
  for k, v in pairs(t) do
    if tonumber(k) then
      t[k] = v:lower()
    else
      t[k:lower()] = v
    end
  end
  if not (t[room:lower()] or table.contains(t, room:lower())) then
    return
  end
  echo("\n")
  if table.size(t) == 1 then
    local k, v = next(t)
    cecho(
      "&lt;red&gt;From your knowledge, that room is in &lt;orange_red&gt;" ..
      mmp.cleanAreaName(mmp.areatabler[getRoomArea(type(k) == "number" and k or v)] or "?") ..
      "&lt;red&gt;."
    )
  else
    local k, v = next(t)
    local areas = {}
    if type(k) == "number" then
      for k, _ in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or "?"] = true
      end
    else
      for _, k in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or "?"] = true
      end
    end
    local flattened_areas = {}
    for k, _ in pairs(areas) do
      if k ~= "" then
        flattened_areas[#flattened_areas + 1] = mmp.cleanAreaName(k)
      end
    end
    cecho(
      "&lt;red&gt;From your knowledge, that room might be in &lt;orange_red&gt;" ..
      table.concat(flattened_areas, ", or ") ..
      "&lt;red&gt;."
    )
  end
  if person then
    mmp.pdb[person] = room
    mmp.pdb_lastupdate[person] = true
    raiseEvent("mmapper updated pdb")
  end
end

function mmp.locateAndEchoSide(room, person)
  local t = mmp.searchRoomExact(room)
  echo("  (")
  mmp.echonums(room)
  echo(")")
  -- lowercase results
  for k, v in pairs(t) do
    if tonumber(k) then
      t[k] = v:lower()
    else
      t[k:lower()] = v
    end
  end
  if not (t[room:lower()] or table.contains(t, room:lower())) then
    return
  end
  --echo"\n"
  if table.size(t) == 1 then
    local k, v = next(t)
    cecho(
      "&lt;red&gt;  (" ..
      mmp.cleanAreaName(mmp.areatabler[getRoomArea(type(k) == "number" and k or v)] or "?") ..
      ")"
    )
  else
    local k, v = next(t)
    local areas = {}
    if type(k) == "number" then
      for k, _ in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or "?"] = true
      end
    else
      for _, k in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or "?"] = true
      end
    end
    local flattened_areas = {}
    for k, _ in pairs(areas) do
      if k ~= "" then
        flattened_areas[#flattened_areas + 1] = mmp.cleanAreaName(k)
      end
    end
    cecho("&lt;red&gt; (" .. table.concat(flattened_areas, ", ") .. ")")
  end
  if person then
    mmp.pdb[person] = room
    mmp.pdb_lastupdate[person] = true
    raiseEvent("mmapper updated pdb")
  end
end

function mmp.locateAndEchoInternal(room, person)
  local t = mmp.searchRoomExact(room)
  -- lowercase results
  for k, v in pairs(t) do
    if tonumber(k) then
      t[k] = v:lower()
    else
      t[k:lower()] = v
    end
  end
  if not (t[room:lower()] or table.contains(t, room:lower())) then
    return
  end
  --echo"\n"
  if table.size(t) == 1 then
    local k, v = next(t)
    cecho(
      "&lt;red&gt; in " ..
      mmp.cleanAreaName(mmp.areatabler[getRoomArea(type(k) == "number" and k or v)] or "?") ..
      "."
    )
  else
    local k, v = next(t)
    local areas = {}
    if type(k) == "number" then
      for k, _ in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or "?"] = true
      end
    else
      for _, k in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or "?"] = true
      end
    end
    local flattened_areas = {}
    for k, _ in pairs(areas) do
      if k ~= "" then
        flattened_areas[#flattened_areas + 1] = mmp.cleanAreaName(k)
      end
    end
    cecho("&lt;red&gt; in " .. table.concat(flattened_areas, ", ") .. ".")
  end
  echo("  (")
  mmp.echonums(room, true)
  echo(")")
  if person then
    mmp.pdb[person] = room
    mmp.pdb_lastupdate[person] = true
    raiseEvent("mmapper updated pdb")
  end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Aliases</name>
						<packageName></packageName>
						<script>function mmp.roomWhoFind(query)
  if query:ends('.') then
    query = query:sub(1, -2)
  end
  local result = mmp.searchRoomExact(query)
  if type(result) == "string" or not next(result) then
    cecho("&lt;CadetBlue&gt;  You have no recollection of any room with that name.")
    return
  end
  if not tonumber(select(2, next(result))) then
    -- old style
    for roomid, roomname in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(
        string.format(
          "&lt;DarkSlateGrey&gt;) &lt;white&gt;%s&lt;DarkSlateGrey&gt;.\n",
          tostring(mmp.areatabler[getRoomArea(roomid)])
        )
      )
    end
  else
    -- new style
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(
        string.format(
          "&lt;DarkSlateGrey&gt;) &lt;white&gt;%s&lt;DarkSlateGrey&gt;.\n",
          tostring(mmp.areatabler[getRoomArea(roomid)])
        )
      )
    end
  end
end

function mmp.roomFind(query)
  if query:ends('.') then
    query = query:sub(1, -2)
  end
  local result = mmp.searchRoom(query)
  if type(result) == "string" or not next(result) then
    cecho("&lt;grey&gt;You have no recollection of any room with that name.")
    return
  end
  cecho("&lt;DarkSlateGrey&gt;You know the following relevant rooms:\n")

  local function showmeropis(roomid)
    if mmp.game ~= "achaea" then
      return ''
    end
    return mmp.oncontinent(getRoomArea(roomid), "Main") and '' or ' (Meropis)'
  end

  if not tonumber(select(2, next(result))) then
    -- old style
    for roomid, roomname in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(
        string.format(
          "&lt;DarkSlateGrey&gt;) in &lt;LightSlateGray&gt;%s%s&lt;DarkSlateGrey&gt;.",
          mmp.cleanAreaName(tostring(mmp.areatabler[getRoomArea(roomid)])),
          showmeropis(roomid)
        )
      )
      fg("DarkSlateGrey")
      echoLink(
        " &gt; Show path\n",
        [[mmp.echoPath(mmp.currentroom, ]] .. roomid .. [[)]],
        "Display directions from here to " .. roomname,
        true
      )
      resetFormat()
    end
  else
    -- new style
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(
        string.format(
          "&lt;DarkSlateGrey&gt;) in &lt;LightSlateGray&gt;%s%s&lt;DarkSlateGrey&gt;.",
          mmp.cleanAreaName(tostring(mmp.areatabler[getRoomArea(roomid)])),
          showmeropis(roomid)
        )
      )
      fg("DarkSlateGrey")
      echoLink(
        " &gt; Show path\n",
        [[mmp.echoPath(mmp.currentroom, ]] .. roomid .. [[)]],
        "Display directions from here to " .. roomname,
        true
      )
      resetFormat()
    end
  end
  cecho(string.format("  &lt;DarkSlateGrey&gt;%d rooms found.\n", table.size(result)))
end

function mmp.echoRoomList(areaname, exact)
  local areaid, msg, multiples = mmp.findAreaID(areaname, exact)
  if areaid then
    local roomlist, endresult = getAreaRooms(areaid) or {}, {}
    -- obtain a room list for each of the room IDs we got
    local getRoomName = getRoomName
    for _, id in pairs(roomlist) do
      endresult[id] = getRoomName(id)
    end
    -- sort room IDs so we can display them in order
    table.sort(roomlist)
    -- now display something half-decent looking
    cecho(
      string.format(
        "&lt;DarkSlateGrey&gt;List of all rooms in &lt;grey&gt;%s&lt;DarkSlateGrey&gt; (areaid &lt;grey&gt;%s&lt;DarkSlateGrey&gt; - &lt;grey&gt;%d&lt;DarkSlateGrey&gt; rooms):\n",
        msg,
        areaid,
        table.size(endresult)
      )
    )
    local echoLink, sformat, fg, echo = echoLink, string.format, fg, cecho
    -- use pairs, as we can have gaps between room IDs
    for _, roomid in pairs(roomlist) do
      local roomname = endresult[roomid]
      fg("blue")
      cechoLink(
        "&lt;" .. mmp.settings.echocolour .. "&gt;" .. sformat("%6s", roomid),
        'mmp.gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(string.format("&lt;DarkSlateGrey&gt;: &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n", roomname))
    end
  elseif not id and #multiples &gt; 0 then
    mmp.echo("For which area would you want to list rooms for?")
    fg("DimGrey")
    for _, areaname in ipairs(multiples) do
      echo("  ");
      setUnderline(true)
      echoLink(
        areaname,
        'mmp.echoRoomList("' .. areaname .. '", true)',
        "Click to view the room list for " .. areaname,
        true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    mmp.echo(string.format("Don't know of any area named '%s'.", areaname))
  end
end

function mmp.echoAreaList()
  local list = getAreaTable()
  local ids, rlist = {}, {}
  local totalroomcount = 0
  for area, id in pairs(list) do
    if id ~= 0 then
      ids[#ids + 1] = id;
      rlist[id] = area
    end
  end
  table.sort(ids)
  -- count the amount of rooms in an area, taking care to count the room in the 0th
  -- index as well if there is one
  -- saves the total room count on the side as well

  local function countrooms(areaid)
    local allrooms = getAreaRooms(areaid) or {}
    local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
    totalroomcount = totalroomcount + areac
    return areac
  end

  cecho(string.format("&lt;DarkSlateGrey&gt;List of all areas we know of (click to view room list):\n"))
  local getAreaRooms, cecho, fg, echoLink, format, rep =
    getAreaRooms, cecho, fg, echoLink, string.format, string.rep
  for _, id in pairs(ids) do
    cecho(format("&lt;" .. mmp.settings.echocolour .. "&gt;%s%d ", rep(" ", (7 - #tostring(id))), id))
    -- +1 because getAreaRooms starts counting at 0
    fg("DarkSlateGrey")
    echoLink(
      rlist[id] .. (" "):rep(40 - #rlist[id]) .. "(" .. mmp.comma_value(countrooms(id)) .. " rooms)",
      'mmp.echoRoomList("' .. rlist[id] .. '", true)',
      "View the room list for " .. rlist[id],
      true
    )
    echo("\n")
  end
  cecho(
    string.format(
      "&lt;DarkSlateGrey&gt;Total amount of rooms in this map: %s\n", mmp.comma_value(totalroomcount)
    )
  )
end

function mmp.clearLabels(areaid)
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= "table" then
      return
    end
    for labelid, _ in pairs(t) do
      deleteMapLabel(areaid, labelid)
    end
  end

  if areaid == "map" then
    for areaid in pairs(mmp.areatabler) do
      clearlabels(areaid)
    end
    mmp.echo("Cleared labels in all of the map.")
    return
  end
  clearlabels(areaid)
  mmp.echo(string.format("Cleared all labels in '%s'.", mmp.areatabler[areaid]))
end

function mmp.deleteArea(name, exact)
  local id, fname, ma = mmp.findAreaID(name, exact)
  if id then
    mmp.doareadelete(id)
  elseif next(ma) then
    mmp.echo("Which one of these specifically would you like to delete?")
    fg("DimGrey")
    for _, name in ipairs(ma) do
      echo("  ")
      setUnderline(true)
      echoLink(name, [[mmp.deleteArea("]] .. name .. [[", true)]], "Delete " .. name, true)
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    mmp.echo("Don't know of that area.")
  end
  raiseEvent("mmp areas changed")
end

-- the function actually doing area deletion

function mmp.doareadelete(areaid)
  mmp.deletingarea = {}
  local t = mmp.deletingarea
  local rooms = getAreaRooms(areaid)
  t.roomcount = table.size(rooms)
  t.roombatches = {}
  t.currentbatch = 1
  t.areaid = areaid
  t.areaname = getAreaTableSwap()[areaid]
  -- delete the area right away if there's nothing in it
  if t.roomcount == 0 then
    deleteArea(t.areaid)
    mmp.echo("All done! The area was already gone/empty.")
  end
  local rooms_per_batch = 100
  -- split up rooms into tables of tables, to be deleted in batches so
  -- that our print statements in between get a chance to be processed
  for batch = 1, t.roomcount, 100 do
    t.roombatches[#t.roombatches + 1] = {}
    local onebatch = t.roombatches[#t.roombatches]
    for inbatch = 1, 100 do
      onebatch[#onebatch + 1] = rooms[batch + inbatch]
    end
  end

  function mmp.deletenextbatch()
    local t = mmp.deletingarea
    if not t then
      return
    end
    local currentbatch = t.roombatches[t.currentbatchi]
    if currentbatch == nil then
      deleteArea(t.areaid)
      mmp.echo("All done! Deleted the '" .. t.areaname .. "' area.")
      mmp.deletingarea = nil
      centerview(mmp.currentroom)
      return
    end
    local deleteRoom = deleteRoom
    for i = 1, #currentbatch do
      deleteRoom(currentbatch[i])
    end
    mmp.echo(
      string.format(
        "Deleted %d batch%s so far, %d left to go - %.2f%% done out of %d needed",
        t.currentbatchi,
        (t.currentbatchi == 1 and '' or 'es'),
        #t.roombatches - t.currentbatchi,
        (100 / #t.roombatches) * t.currentbatchi,
        #t.roombatches
      )
    )
    t.currentbatchi = t.currentbatchi + 1
    tempTimer(0.010, mmp.deletenextbatch)
  end

  t.currentbatchi = 1
  mmp.echo("Prepped room batches, starting deletion...")
  tempTimer(0.010, mmp.deletenextbatch)
end

function mmp.renameArea(name, exact)
  if not (mmp.currentroom or getRoomArea(mmp.currentroom)) then
    mmp.echo("Don't know what area are we in at the moment, to rename it.")
  else
    setAreaName(getRoomArea(mmp.currentroom), name)
    mmp.echo(
      string.format(
        "Renamed %s to %s (%d).",
        mmp.areatabler[getRoomArea(mmp.currentroom)],
        name,
        getRoomArea(mmp.currentroom)
      )
    )
    centerview(mmp.currentroom)
  end
  raiseEvent("mmp areas changed")
end

function mmp.roomArea(otherroom, name, exact)
  local id, fname, ma
  if tonumber(name) then
    id = tonumber(name);
    fname = mmp.areatabler[id]
  else
    id, fname, ma = mmp.findAreaID(name, exact)
  end
  if otherroom ~= "" and not mmp.roomexists(otherroom) then
    mmp.echo("Room id " .. otherroom .. " doesn't seem to exist.")
    return
  elseif otherroom == "" and not mmp.roomexists(mmp.currentroom) then
    mmp.echo("Don't know where we are at the moment.")
    return
  end
  otherroom = otherroom ~= "" and otherroom or mmp.currentroom
  if id then
    setRoomArea(otherroom, id)
    mmp.echo(
      string.format(
        "Moved %s to %s (%d).",
        (getRoomName(otherroom) ~= "" and getRoomName(otherroom) or "''"),
        fname,
        id
      )
    )
    centerview(otherroom)
  elseif next(ma) then
    mmp.echo("Into which area exactly would you like to move the room?")
    fg("DimGrey")
    for _, name in ipairs(ma) do
      echo("  ")
      setUnderline(true)
      echoLink(
        name, [[mmp.roomArea('', "]] .. name .. [[", true)]], "Move the room to " .. name, true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    mmp.echo("Don't know of that area.")
  end
end

function mmp.getAreaBorders(areaid)
  if mmp.debug then
    mmp.getAreaBordersTimer = mmp.getAreaBordersTimer or createStopWatch()
    startStopWatch(mmp.getAreaBordersTimer)
  end
  -- make sure we have all exits into the area.
  raiseEvent("mmp link externals")
  local roomlist, endresult = getAreaRooms(areaid), {}
  -- sometimes getAreaRooms can give us no result :(
  if not roomlist then
    mmp.echo(
      "Sorry, seems we can't go there - getAreaRooms(" ..
      areaid ..
      ") didn't give us any results (Mudlet problem - redownloading the map might help fix it)"
    )
    return
  end
  if table.is_empty(roomlist) then
    mmp.echo(
      "Sorry, seems we can't go there - " .. getRoomAreaName(areaid) .. " has no rooms in it."
    )
    return
  end
  -- make a key-value list of room IDs
  local reverselist = {}
  for i = 0, #roomlist do
    reverselist[roomlist[i]] = true
  end
  local getRoomName, contains, pairs = getRoomName, table.contains, pairs
  if getAllRoomEntrances then
    for i = 0, #roomlist do
      local id = roomlist[i]
      local entrancesFrom = getAllRoomEntrances(id)
      for remoteRoomIndex = 1, #entrancesFrom do
        if not reverselist[entrancesFrom[remoteRoomIndex]] then
          endresult[id] = getRoomName(id)
        end
      end
    end
  else
    local getRoomExits, getSpecialExitsSwap = getRoomExits, getSpecialExitsSwap
    -- obtain a room list for each of the room IDs we got
    --for _, id in pairs(roomlist) do
    for i = 0, #roomlist do
      local id = roomlist[i]
      local exits = getRoomExits(id)
      for _, to in pairs(exits) do
        if not reverselist[to] then
          endresult[id] = getRoomName(id)
        end
      end
      local specialexits = getSpecialExitsSwap(id)
      for _, to in pairs(specialexits) do
        if not reverselist[to] then
          endresult[id] = getRoomName(id)
        end
      end
    end
  end
  if mmp.debug then
    mmp.echo(
      "mmp.getAreaBordersTimer() on areaid " ..
      areaid ..
      " took " ..
      stopStopWatch(mmp.getAreaBordersTimer) ..
      "s to run. Returned " ..
      table.size(endresult) ..
      " results."
    )
  end
  -- clean up external exits
  raiseEvent("mmp clear externals")
  return endresult
end

function mmp.viewArea(where, exact)
  if not where or not type(where) == "string" then
    mmp.echo("Which area would you like to view?")
    return
  end
  local areaid, msg, multiples = mmp.findAreaID(where, exact)
  if areaid then
    -- center on the first room ID, which typically is the start of an area
    local rooms = getAreaRooms(areaid) or {}
    if not rooms[1] then
      mmp.echo("The area has no rooms in it.")
    else
      centerview(rooms[1])
    end
  elseif not areaid and #multiples &gt; 0 then
    mmp.echo("Which area would you like to view exactly?")
    fg("DimGrey")
    for _, areaname in ipairs(multiples) do
      echo("  ");
      setUnderline(true)
      echoLink(
        areaname, 'mmp.viewArea("' .. areaname .. '", true)', "Click to view " .. areaname, true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
    return
  else
    mmp.echo(string.format("Don't know of any area named '%s'.", where))
    return
  end
end

-- room label the room I'm in
-- room label 342 this is a label in room 342
-- room label green this is a green label where I'm at
-- room label green black this is a green to black label where I'm at
-- room label 34 green black this is a green to black label at room 34
-- how it works: split input string into tokens by space, then determine
-- what to do by checking first few tokens, and finally call the local
-- function with the proper arguments

function mmp.roomLabel(input)
  if not createMapLabel then
    mmp.echo(
      "Your Mudlet doesn't support createMapLabel() yet - please update to 2.0-test3 or better."
    )
    return
  end
  local tk = input:split(" ")
  local room, fg, bg, message = mmp.currentroom, "yellow", "red", "Some room label"
  -- input always have to be something, so tk[1] at least always exists
  if tonumber(tk[1]) then
    room = tonumber(table.remove(tk, 1))
    -- remove the number, so we're left with the colors or msg
  end
  -- next: is this a foreground color?
  if tk[1] and color_table[tk[1]] then
    fg = table.remove(tk, 1)
  end
  -- next: is this a backround color?
  if tk[1] and color_table[tk[1]] then
    bg = table.remove(tk, 1)
  end
  -- the rest would be our message
  if tk[1] then
    message = table.concat(tk, " ")
  end
  -- if we haven't provided a room ID and we don't know where we are yet, we can't make a label
  if not room then
    mmp.echo("We don't know where we are to make a label here.")
    return
  end
  local x, y = getRoomCoordinates(room)
  local f1, f2, f3 = unpack(color_table[fg])
  local b1, b2, b3 = unpack(color_table[bg])
  -- finally: do it :)
  local lid = createMapLabel(getRoomArea(room), message, x, y, f1, f2, f3, b1, b2, b3)
  mmp.echo(
    string.format(
      "Created new label #%d '%s' in %s.", lid, message, getRoomAreaName(getRoomArea(room))
    )
  )
end

function mmp.areaLabels(where, exact)
  if not getMapLabels then
    mmp.echo(
      "Your Mudlet doesn't support getMapLabels() yet - please update to 2.0-test3 or better."
    )
    return
  end
  if (not where or not type(where) == "string") and not mmp.currentroom then
    mmp.echo("For which area would you like to view labels?")
    return
  end
  if not where then
    exact = true
    where = getRoomAreaName(getRoomArea(mmp.currentroom))
  end
  local areaid, msg, multiples = mmp.findAreaID(where, exact)
  if areaid then
    local t = getMapLabels(areaid)
    if type(t) ~= "table" or not next(t) then
      mmp.echo(string.format("'%s' doesn't seem to have any labels.", getRoomAreaName(areaid)))
      return
    end
    mmp.echo(string.format("Area labels for '%s'", getRoomAreaName(areaid)))
    for labelid, labeltext in pairs(t) do
      fg("DimGrey")
      echo(string.format("  %d) %s (", labelid, labeltext))
      fg("orange_red")
      setUnderline(true)
      echoLink(
        'delete',
        string.format(
          'deleteMapLabel(%d, %d); mmp.echo("Deleted label #' .. labelid .. '")', areaid, labelid
        ),
        "Delete label #" .. labelid .. " from " .. getRoomAreaName(areaid)
      )
      setUnderline(false)
      echo(")\n")
    end
    resetFormat()
  elseif not areaid and #multiples &gt; 0 then
    mmp.echo("Which area would you like to view exactly?")
    fg("DimGrey")
    for _, areaname in ipairs(multiples) do
      echo("  ");
      setUnderline(true)
      echoLink(
        areaname,
        'mmp.areaLabels("' .. areaname .. '", true)',
        "Click to view labels in " .. areaname,
        true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
    return
  else
    mmp.echo(string.format("Don't know of any area named '%s'.", where))
    return
  end
end

function mmp.echoPath(from, to)
  assert(tonumber(from) and tonumber(to), "mmp.getPath: both from and to have to be room IDs")
  if mmp.getPath(from, to) then
    mmp.echo(
      "&lt;white&gt;Directions from &lt;yellow&gt;" ..
      string.upper(searchRoom(from)) ..
      " &lt;white&gt;to &lt;yellow&gt;" ..
      string.upper(searchRoom(to)) ..
      "&lt;white&gt;:"
    )
    mmp.echo(table.concat(speedWalkDir, ", "))
    return mmp.speedWalkDir
  else
    mmp.echo(
      "&lt;white&gt;I can't find a way from &lt;yellow&gt;" ..
      string.upper(searchRoom(from)) ..
      " &lt;white&gt;to &lt;yellow&gt;" ..
      string.upper(searchRoom(to)) ..
      "&lt;white&gt;"
    )
  end
end

function mmp.listSpecialExits(filter)
  local c = 0
  mmp.echo("Listing special exits...")
  for area, areaname in pairs(mmp.areatabler) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == "table" then
            cmd = next(cmd)
          end
          if cmd:match("^%d") then
            cmd = cmd:sub(2)
          end
          if not filter or cmd:lower():find(filter, 1, true) then
            if getRoomArea(exit) ~= area then
              cecho(
                string.format(
                  "&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d, in %s)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s -&lt;MediumSlateBlue&gt;&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d, in %s)\n",
                  getRoomName(rooms[i]),
                  rooms[i],
                  areaname,
                  cmd,
                  getRoomName(exit),
                  exit,
                  mmp.areatabler[getRoomArea(exit)] or '?'
                )
              )
            else
              cecho(
                string.format(
                  "&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s &lt;MediumSlateBlue&gt;-&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; in %s\n",
                  getRoomName(rooms[i]),
                  rooms[i],
                  cmd,
                  getRoomName(exit),
                  exit,
                  areaname
                )
              )
            end
            c = c + 1
          end
        end
      end
    end
  end
  mmp.echo(
    string.format(
      "%d exits listed%s.", c, (not filter and '' or ", with for the filter '" .. filter .. "'")
    )
  )
end

function mmp.delSpecialExits(filter)
  local c = 0
  for area, areaname in pairs(mmp.areatabler) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == "table" then
            cmd = next(cmd)
          end
          if cmd:match("^%d") then
            cmd = cmd:sub(2)
          end
          if not filter or cmd:lower():find(filter, 1, true) then
            local rid, action
            local originalExits = {}
            local e = getSpecialExits(rooms[i])
            for t, n in pairs(e) do
              rid = tonumber(t)
              for a, l in pairs(n) do
                action = tostring(a)
              end
              if not action:find(filter, 1, true) then
                originalExits[rid] = action
              end
            end
            clearSpecialExits(rooms[i])
            for rid, act in pairs(originalExits) do
              addSpecialExit(rooms[i], tonumber(rid), tostring(act))
            end
            c = c + 1
          end
        end
      end
    end
  end
  mmp.echo(
    string.format(
      "%d exits deleted%s.", c, (not filter and '' or ", with for the filter '" .. filter .. "'")
    )
  )
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Directions-translating functions</name>
						<packageName></packageName>
						<script>-- translates n to north and so forth
local temp = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    i = "in",
    o = "out",
    ["in"] = "in"
}
local anytolongmap = {}
for s, l in pairs(temp) do anytolongmap[l] = l; anytolongmap[s] = l end
function mmp.anytolong(exit)

  return anytolongmap[exit]
end

function mmp.anytoshort(exit)
  local t = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    ["in"] = "in",
    out = "out"
  }
  local rt = {}
  for s,l in pairs(t) do
    rt[l] = s; rt[s] = s
  end

  return rt[exit]
end


function mmp.ranytolong(exit)
  local t = {
    n = "south",
    north = "south",
    e = "west",
    east = "west",
    s = "north",
    south = "north",
    w = "east",
    west = "east",
    ne = "southwest",
    northeast = "southwest",
    se = "northwest",
    southeast = "northwest",
    sw = "northeast",
    southwest = "northeast",
    nw = "southeast",
    northwest = "southeast",
    u = "down",
    up = "down",
    d = "up",
    down = "up",
    i = "out",
    ["in"] = "out",
    o = "in",
    out = "in"
  }

  return t[exit]
end

-- returns nil or the room number relative to this one
function mmp.relativeroom(from, dir)
  if not mmp.roomexists(from) then return end

  local exits = getRoomExits(tonumber(from))
  return exits[mmp.anytolong(dir)]
end
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mconfig settings functions</name>
						<packageName></packageName>
						<script>function mmp.doLock(what, lock, filter)
  if what then mmp.echo(string.format("%s all %s...", (lock and "Locking" or "Unlocking"), what)) end
  local c = 0

  local getAreaRooms, getSpecialExits, lockSpecialExit, next = getAreaRooms, getSpecialExits, lockSpecialExit, next
  for _, area in pairs(getAreaTable()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)

       if exits and next(exits) then
         for exit, cmd in pairs(exits) do
           if type(cmd) == "table" then cmd = next(cmd) end

           if (not filter and not (cmd:lower():find("pathfind", 1, true) or cmd:lower():find("worm warp", 1, true) or cmd:lower():find("enter grate", 1, true))) or (filter and cmd:lower():find(filter, 1, true)) then
             lockSpecialExit(rooms[i], exit, cmd, lock)
             c = c + 1
           end
         end
       end
    end
  end

  if what then mmp.echo(string.format("%s %s known %s.", (lock and "Locked" or "Unlocked"), c, what)) end
  return c
end

function mmp.changeEchoColour()
    mmp.echo("Now displaying echos in &lt;"..mmp.settings.echocolour.."&gt;"..mmp.settings.echocolour )
end

function mmp.lockPathways()
  local lock = mmp.settings.lockpathways and true or false
  mmp.doLock("pathways", lock, "pathfind")
end

function mmp.lockSewers()
  local lock = mmp.settings.locksewers and true or false
  return mmp.doLock("sewer grates", lock, "enter grate")
end

function mmp.lockWormholes()
  local lock = mmp.settings.lockwormholes and true or false
  return mmp.doLock("wormholes", lock, "worm warp")
end
tempTimer(0, function() if mmp.firstRun then mmp.lockWormholes() end end)

function mmp.lockPebble()
  local disabled = (not mmp.settings.pebble) and true or false
  mmp.doLock(nil, disabled, "touch 116998")
  mmp.doLock(nil, disabled, "touch 277930")

  mmp.echo(string.format("Use of pebble %s.", disabled and "disabled" or "enabled"))
end

function mmp.lockSpecials()
  local lock = mmp.settings.lockspecials and true or false
  mmp.doLock("special exits", lock)
end

function mmp.setDuanathar()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.duanathar then mmp.echo("Okay, will see about using Eagle wings when you goto somewhere while outside!")
  else mmp.echo("Won't use Eagle wings anymore.") end
end

function mmp.setDuanatharan()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.duanatharan then mmp.echo("Okay, will see about using Atavian wings (both duanathar and duanatharan) when you goto somewhere while outside!")
  else mmp.echo("Won't use Atavian wings anymore.") end
end

function mmp.setDuanatharic()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.duanatharic then mmp.echo("Okay, will see about using Island wings when you goto somewhere while outside!")
  else mmp.echo("Won't use Island wings anymore.") end
end

function mmp.setDuantahar()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.duantahar then mmp.echo("Okay, will see about using Chenubian wings (duanathar, duanatharan, and duantahar) when you goto somewhere while outside!")
  else mmp.echo("Won't use Chenubian wings anymore.") end
end

function mmp.setSoar()
  mmp.clearpathcache() -- clear the cache so it'll use soar or will stop using soar

  if mmp.settings.soar then mmp.echo("Okay, will see about using Aero Soar when you goto somewhere while outside!")
  else mmp.echo("Won't use Aero Soar anymore.") end
end

function mmp.setUniverse()
  mmp.clearpathcache()
	
	if mmp.settings.universe then mmp.echo("Okay, will see about using the Universe tarot whenever it's faster.")
	else mmp.echo("Won't use Universe tarot anymore.") end

end

function mmp.setGare()
  mmp.clearpathcache() -- clear the cache so it'll use gare or stop using gare

  if mmp.settings.gare then mmp.echo("Okay, will see about using Gare when in Dragon form!")
  else mmp.echo("Won't use Gare anymore.") end
end

function mmp.chageMapSource()
  local use = mmp.settings.crowdmap and true or false
  if use and not (mmp.game == "achaea" or mmp.game == "starmourn" or mmp.game == "lusternia") then
    mmp.echo("Sorry - the crowdsourced map is only available for use in Achaea or Starmourn. If you'd like to help start one for your game, please post at http://forums.mudlet.org/viewtopic.php?f=13&amp;t=1696. If you are playing one of the games, then it is likely that you just downloaded the script - and it doesn't know what you are playing. Reconnect and it'll know.")
    mmp.settings.crowdmap = false
  elseif use and not loadMap then
   mmp.echo("Sorry - your Mudlet is too old and can't load maps. Please update: http://forums.mudlet.org/viewtopic.php?f=5&amp;t=1874")
   mmp.settings.crowdmap = false
  elseif use then
    mmp.echo("Will use the crowdsourced map for updates instead!")
    mmp.checkforupdate()
  else
    mmp.echo("Will use the default game map for updates.")
  end
end

function mmp.setWingsLanguage()
  mmp.echo("Alright, will say Duanathar and Duanathar in "..mmp.settings.winglanguage:title()..".")
end

function mmp.setWingsRemoval()
  mmp.echo("Okay - "..(mmp.settings.removewings and "will" or "won't").." remove wings after using them.")
end

function mmp.setSlowWalk()
  if mmp.settings.slowwalk then
    mmp.echo("Will walk 'slowly' - that is, only try to move in a direction once per room, and move again once we've arrived. This will make us better walkers when it's very laggy, as we won't spam directions unnecessarily and miss certain turns - but it does mean that if we fail to move for some reason, we won't retry again either at all.")
  else
    mmp.echo("Will walk as quick as we can!")
  end
end

function mmp.disableWaterWalk()
  local c = 0
  local getRoomEnv, setRoomWeight = getRoomEnv, setRoomWeight
  for roomid, roomname in pairs(getRooms()) do
    if mmp.waterenvs[getRoomEnv(roomid)] then
      setRoomWeight(roomid, 3)
      c = c + 1
    end
  end

  return c
end

function mmp.enableWaterWalk()
  local c = 0
  local getRoomEnv, setRoomWeight = getRoomEnv, setRoomWeight
  for roomid, roomname in pairs(getRooms()) do
    if mmp.waterenvs[getRoomEnv(roomid)] then
      setRoomWeight(roomid, 1)
      c = c + 1
    end
  end

  return c
end

function mmp.setWaterWalk()
  if mmp.settings.waterwalk then
    mmp.echo("Enabled waterwalk for "..mmp.enableWaterWalk().." rooms - so we'll be treating land and water rooms the same now in terms of traverse speed over them.")
  else
    mmp.echo("Disabled waterwalk for "..mmp.disableWaterWalk().." rooms - so we'll be preferring land rooms over water ones wherever it's quicker.")
  end
end

function mmp.setMedallion()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.medallion then mmp.echo("Okay, will see about using Medallion whenever it's quicker")
  else mmp.echo("Won't use Medallion anymore.") end
end

function mmp.setFingerblade()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.fingerblade then mmp.echo("Okay, will see about using Fingerblade whenever it's quicker")
  else mmp.echo("Won't use Fingerblade anymore.") end
end

function mmp.setBlossom()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.blossom then mmp.echo("Okay, will see about using the Flame whenever it's quicker")
  else mmp.echo("Won't use the Flame anymore.") end
end

function mmp.setMandala()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.mandala then mmp.echo("Okay, will see about using Mandala whenever it's quicker")
  else mmp.echo("Won't use Mandala anymore.") end
end

function mmp.setBelt()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.belt then mmp.echo("Okay, will see about using Belt whenever it's quicker")
  else mmp.echo("Won't use Belt anymore.") end
end

function mmp.setCubix()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.cubix then mmp.echo("Okay, will see about using Cubix whenever it's quicker")
  else mmp.echo("Won't use Cubix anymore.") end
end

function mmp.setPrism()
	mmp.clearpathcache()
	if mmp.settings.prism then mmp.echo("Okay, will see about using Prism whenever it's quicker")
	else mmp.echo("Won't use Prism anymore.") end
end

function mmp.setScrewdriver()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.screwdriver then mmp.echo("Okay, will see about using Screwdriver whenever it's quicker")
  else mmp.echo("Won't use Screwdriver anymore.") end
end

function mmp.setWheel()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.wheel then mmp.echo("Okay, will see about using Wheel whenever it's quicker")
  else mmp.echo("Won't use Wheel anymore.") end
end

function mmp.setMud()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.mud then mmp.echo("Okay, will see about using Mud whenever it's quicker")
  else mmp.echo("Won't use Mud anymore.") end
end
function mmp.setSnowglobe()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.snowglobe then mmp.echo("Okay, will see about using Snowglobe whenever it's quicker")
  else mmp.echo("Won't use Snowglobe anymore.") end
end

function mmp.setCookie()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.cookie then mmp.echo("Okay, will see about using Cookie whenever it's quicker")
  else mmp.echo("Won't use Cookie anymore.") end
end

function mmp.setHead()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.head then mmp.echo("Okay, will see about using Doll's Head whenever it's quicker")
  else mmp.echo("Won't use Doll's Head anymore.") end
end

function mmp.setIcicle()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.icicle then mmp.echo("Okay, will see about using Icicle whenever it's quicker")
  else mmp.echo("Won't use Icicle anymore.") end
end

function mmp.setTibia()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.tibia then mmp.echo("Okay, will see about using Tibia whenever it's quicker")
  else mmp.echo("Won't use Tibia anymore.") end
end

function mmp.setBonecurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.bonecurio then mmp.echo("Okay, will see about using Bone Curio collection whenever it's quicker")
  else mmp.echo("Won't use Bone Curio collection anymore.") end
end

function mmp.setFlowercurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.flowercurio then mmp.echo("Okay, will see about using Flower Curio collection whenever it's quicker")
  else mmp.echo("Won't use Flower Curio collection anymore.") end
end

function mmp.setTorus()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.torus then mmp.echo("Okay, will see about using your Torus whenever it's quicker")
  else mmp.echo("Won't use your Torus anymore.") end
end

function mmp.setUtensilcurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.utensilcurio then mmp.echo("Okay, will see about using Utensil Curio collection whenever it's quicker")
  else mmp.echo("Won't use Utensil Curio collection anymore.") end
end

function mmp.setFluttercurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.fluttercurio then mmp.echo("Okay, will see about using Flutter Curio collection whenever it's quicker")
  else mmp.echo("Won't use Flutter Curio collection anymore.") end
end

function mmp.setToolcurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.toolcurio then mmp.echo("Okay, will see about using Tool Curio collection whenever it's quicker")
  else mmp.echo("Won't use Tool Curio collection anymore.") end
end

function mmp.setFacecurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.facecurio then mmp.echo("Okay, will see about using Face Curio collection whenever it's quicker")
  else mmp.echo("Won't use Face Curio collection anymore.") end
end

function mmp.setToycurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.toycurio then mmp.echo("Okay, will see about using Toy Curio collection whenever it's quicker")
  else mmp.echo("Won't use Toy Curio collection anymore.") end
end

function mmp.setFeathercurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.feathercurio then mmp.echo("Okay, will see about using Feather Curio collection whenever it's quicker")
  else mmp.echo("Won't use Feather Curio collection anymore.") end
end

function mmp.setFigurecurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.figurecurio then mmp.echo("Okay, will see about using Figure Curio collection whenever it's quicker")
  else mmp.echo("Won't use Figure Curio collection anymore.") end
end

function mmp.setVernalcurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.vernalcurio then mmp.echo("Okay, will see about using Vernal Curio collection whenever it's quicker")
  else mmp.echo("Won't use Vernal Curio collection anymore.") end
end
function mmp.setSoullesscurio()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.soullesscurio then mmp.echo("Okay, will see about using Soulless Curio collection whenever it's quicker")
  else mmp.echo("Won't use Soulless Curio collection anymore.") end
end

function mmp.setHarness() --PapaGuacamole
  mmp.clearpathcache() -- clear the cache so it'll use harness or will stop using harness

  if mmp.settings.harness then mmp.echo("Okay, will use Stratospheric Harness when on appropriate islands")
  else mmp.echo("Won't use Stratospheric Harness anymore.") end
end

function mmp.setMantle()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.mantle then mmp.echo("Okay, will see about using Mantle of Starlight whenever it's quicker")
  else mmp.echo("Won't use Mantle of Starlight anymore.") end
end

function mmp.setKey()
  mmp.clearpathcache() -- clear the cache so it'll use wings or will stop using wings

  if mmp.settings.key then mmp.echo("Okay, will see about using your Infernal Key whenever it's quicker")
  else mmp.echo("Won't use the Infernal Key anymore.") end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>API</name>
						<packageName></packageName>
						<script>-------------------------------------------------
-- This script lists some of the API functions available from the IRE mudlet-mapper
-- not all functions that are available are included here, however.

function mmp.echo(what)
  what = what or ""
  moveCursorEnd("main") if getCurrentLine() ~= "" then echo"\n" end
  decho("&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;")
  cecho(tostring(what))
  echo("\n")
end

function mmp.echon(what)
  moveCursorEnd("main") if getCurrentLine() ~= "" then echo"\n" end
  decho("&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;")
  cecho(tostring(what))
end

function mmp.deleteLineP()
  deleteLine()
  tempLineTrigger(1,1,[[
    if isPrompt() then deleteLine() end
  ]])
end

function mmp.pause(what)
  assert(what == nil or what == "on" or what == "off", "mmp.pause wants 'on', 'off' or nothing as an argument")

  if what == "on" or (what == nil and not mmp.paused) then
    mmp.paused = true
  elseif  what == "off" or (what == nil and mmp.paused) then
    mmp.paused = false
  end

  mmp.echo("Speedwalking " .. (mmp.paused and "paused" or "unpaused") .. ".")
  if not mmp.paused then mmp.move() end
end

function mmp.mapLook(roomid, delay)
  centerview(roomid)
  if mmp.maplooktimer then killTimer(mmp.maplooktimer) end
  mmp.maplooktimer = tempTimer(tonumber(delay) or 4, [[centerview(mmp.currentroom); mmp.maplooktimer = nil]])
end

function mmp.getnums(roomname, exact)
  if tonumber(roomname) then return {roomname} end

  local t = (not exact and mmp.searchRoom or mmp.searchRoomExact)(roomname)

  if not t or not next(t) then
    return nil end

  local result = {}

  if not tonumber(select(2, next(t))) then
    for roomid,_ in pairs(t) do
      if roomid ~= 0 then result[#result+1] = tonumber(roomid) end
    end
  else
    for _,roomid in pairs(t) do
      if roomid ~= 0 then result[#result+1] = tonumber(roomid) end
    end
  end

  return result
end

-- searchRoom with a cache!
local cache = {}
setmetatable(cache, {__mode = "kv"}) -- weak keys/values = it'll periodically get cleaned up by gc

function mmp.searchRoom(what)
  local result = cache[what]
  if not result then
    result = searchRoom(what)
    local realResult = {}
    for key, value in pairs(type(result) == "table" and result or {}) do
        -- both ways, because searchRoom can return either id-room name or the reverse
        if type(key) == "string" then
          realResult[key:ends(" (road)") and key:sub(1, -8) or key] = value
        else
          realResult[key] = value:ends(" (road)") and value:sub(1, -8) or value
        end
    end
    cache[what] = realResult
    result = realResult
  end
  return result
end

local function endswith(s, suffix)
    return s:sub(#s - #suffix + 1) == suffix
end

function mmp.searchRoomExact(what)
  if type(what) ~= 'string' then return end

  local roomTable = mmp.searchRoom(what)
  local realResult = {}
  what = what:lower()
  for key, value in pairs (roomTable) do
    if type(key) == "string" and (key:lower() == what or (endswith(key, '.') and key:sub(1, -2) == what)) then
        realResult[key:ends(" (road)") and key:sub(1, -8) or key] = value
    elseif type(value) == "string" and (value:lower() == what or (endswith(value, '.') and value:sub(1, -2) == what)) then
        realResult[key] = value:ends(" (road)") and value:sub(1, -8) or value
    end
  end
  if (table.is_empty(realResult)) then
    return roomTable
  else
    return realResult
  end
end

function mmp.findAreaID(areaname, exact)
  local areaname = areaname:lower()
  local list = getAreaTable()

  -- iterate over the list of areas, matching them with substring match.
  -- if we get match a single area, then return it's ID, otherwise return
  -- 'false' and a message that there are than one are matches
  local returnid, fullareaname, multipleareas = nil, nil, {}
  for area, id in pairs(list) do
    if (not exact and area:lower():find(areaname, 1, true)) or (exact and areaname == area:lower()) then
      returnid = id; fullareaname = area; multipleareas[#multipleareas+1] = area
    end
  end

  if #multipleareas == 1 then
    return returnid, fullareaname
  else
    return nil, nil, multipleareas
  end
end

function mmp.roomexists(num)
  if not num then return false end
  if roomExists then return roomExists(num) end

  local s,m = pcall(getRoomArea, tonumber(num))
  return (s and true or false)
end

function mmp.getcontinents()
  local tmp = getRoomUserData(1, "areaContinents")
  if tmp == "" then return {} end

  return yajl.to_value(tmp)
end

-- patches welcome to finish this function.
function mmp.removecontinent(area, continent)
  local continents = mmp.getcontinents()

  if not next(continents) then return nil, "no continents are known" end
  if not continents[continent] then return nil, "no such continent is recorded" end

  local index = mmp.indexof_valueonly(continents[continent], area)
  if not index then return nil, "this area is not on that continent" end
  table.remove(continents[continent], index)
  local tmp = yajl.to_string(continents)
  setRoomUserData(1, "areaContinents", tmp)
  return true
end

function mmp.addcontinent(areaid, continent)
  local continents = mmp.getcontinents()

  if not next(continents) then return nil, "no continents are known" end
  if not continents[continent] then continents[continent] = {} end

  local index = mmp.indexof_valueonly(continents[continent], areaid)
  if index then return nil, "this area is already on that continent" end
  continents[continent][#continents[continent] + 1] = areaid
  local tmp = yajl.to_string(continents)
  setRoomUserData(1, "areaContinents", tmp)
  return true
end

function mmp.indexof_valueonly(data, value)
  for i = 1, #data do
    if data[i] == value then return i end
  end

  return false
end

-- checks if given area ID is on the given continent. Returns true only if certainly knows
function mmp.oncontinent(areaid, continent)
  local continents = mmp.getcontinents()
  if not continents[continent] then return nil, "no such continent is recorded" end

  return mmp.indexof_valueonly(continents[continent], areaid)
end

function mmp.getareacontinents(areaid)
  local areaContinents = {}
  for continentName, areas in pairs(mmp.getcontinents()) do
    if mmp.indexof_valueonly(areas, areaid) then
      areaContinents[#areaContinents + 1] = continentName
    end
  end
  return areaContinents
end

-- accepts areaname or ID
function mmp.cleanAreaName(area)
  local areaname = type(area) == "number" and mmp.areatabler[area] or area
  if not areaname then return area end

  -- strip , the
  areaname = areaname:gsub(", the$", '')

  -- strip , the Type of
  areaname = areaname:gsub(", the %w+ of$", '')

  -- strip , the Type of (important)
  areaname = areaname:gsub(", the %w+ of %((.+)%)$", " (%1)")

  -- strip , the (important)
  areaname = areaname:gsub(", the %((.+)%)$", " (%1)")

  return areaname
end

-- if this room is in a unique area, report it. Otherwise gives nil
function mmp.getexactarea(roomname)
  local rooms = mmp.searchRoomExact(roomname)

  if not rooms or not next(rooms) then return nil end

  local areaid
  for roomid, roomname in pairs(rooms) do

    local caid = getRoomArea(roomid)
    if areaid and areaid ~= caid then return nil end
    areaid = caid
  end

  if areaid then return mmp.areatabler[areaid] end
end

-- returns the area name of a room or ?
function mmp.getAreaName(roomid)
   return mmp.areatabler[getRoomArea(roomid)] or '?'
end

-- removes extra prefixes and suffixes that are not part of the actual room name
function mmp.cleanroomname(roomname)
  local starts, ends = string.starts, string.ends

  if starts(roomname, "Flying above ") then
    roomname = string.sub(roomname, -(#roomname-13))
  end
  if starts(roomname, "In the trees above ") then
    roomname = string.sub(roomname, -(#roomname-19))
  end
  if starts(roomname, "The ruins of ") then
    roomname = string.sub(roomname, -(#roomname-13))
  end
  if ends(roomname, ".") then
    roomname = string.sub(roomname, 1, (#roomname-1))
  end
  if ends(roomname, " (road)") then
    roomname = string.sub(roomname, 1, (#roomname-7))
  end
  if ends(roomname, " (indoors)") then
    roomname = string.sub(roomname, 1, (#roomname-10))
  end
  if ends(roomname, " (indoor road)") then
    roomname = string.sub(roomname, 1, (#roomname-14))
  end

  return roomname
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp.roomLook</name>
						<packageName></packageName>
						<script>function mmp.roomLook(input)
  -- we can do a report with a number

  local function handle_number(num)
    -- compile all available data
    if not mmp.roomexists(num) then
      mmp.echo(num .. " doesn't seem to exist.")
      return
    end
    local s, areanum = pcall(getRoomArea, num)
    if not s then
      mmp.echo(areanum);
      return ;
    end
    local exits = getRoomExits(num)
    local name = getRoomName(num)
    local islocked = roomLocked(num)
    local weight = (getRoomWeight(num) and getRoomWeight(num) or "?")
    -- getRoomWeight is buggy in one of the versions, is actually linked to setRoomWeight and thus returns nil
    local exitweights = (getExitWeights and getExitWeights(num) or {})
    local coords = {getRoomCoordinates(num)}
    local specexits = getSpecialExits(num)
    local env = getRoomEnv(num)
    local envname = (mmp.envidsr and mmp.envidsr[env]) or "?"
    -- generate a report
    mmp.echo(
      string.format(
        "Room: %s #: %d area: %s (%d)", name, num, tostring(mmp.areatabler[areanum]), areanum
      )
    )
    mmp.echo(
      string.format(
        "Coordinates: x:%d, y:%d, z:%d, locked: %s, weight: %s",
        coords[1],
        coords[2],
        coords[3],
        (islocked and "yep" or "nope"),
        tostring(weight)
      )
    )
    mmp.echo(
      string.format(
        "Environment: %s (%d)%s",
        tostring(envname),
        env,
        (getRoomUserData(num, "indoors") ~= '' and ", indoors" or '')
      )
    )
    mmp.echo(string.format("Exits (%d):", table.size(exits)))
    for exit, leadsto in pairs(exits) do
      echo(
        string.format(
          "  %s -&gt; %s (%d)%s%s\n",
          exit,
          getRoomName(leadsto),
          leadsto,
          (
            (getRoomArea(leadsto) or "?") == areanum and
            "" or
            " (in " ..
            (mmp.areatabler[getRoomArea(leadsto)] or "?") ..
            ")"
          ),
          (
            (not exitweights[mmp.anytoshort(exit)] or exitweights[mmp.anytoshort(exit)] == 0) and
            "" or
            " (weight: " ..
            exitweights[mmp.anytoshort(exit)] ..
            ")"
          )
        )
      )
    end
    -- display special exits if we got any
    if next(specexits) then
      mmp.echo(string.format("Special exits (%d):", table.size(specexits)))
      for leadsto, command in pairs(specexits) do
        if type(command) == "string" then
          echo(string.format("  %s -&gt; %s (%d)\n", command, getRoomName(leadsto), leadsto))
        else
          -- new format - exit name, command
          for cmd, locked in pairs(command) do
            if locked == '1' then
              cecho(
                string.format(
                  "&lt;DarkSlateGrey&gt;  %s -&gt; %s (%d) (locked)\n", cmd, getRoomName(leadsto), leadsto
                )
              )
            else
              echo(string.format("  %s -&gt; %s (%d)\n", cmd, getRoomName(leadsto), leadsto))
            end
          end
        end
      end
    end
    local message = "This room has the feature '%s'."
    for _, mapFeature in pairs(mmp.getRoomMapFeatures(num)) do
      mmp.echo(string.format(message, mapFeature))
    end
    -- actions we can do. This will be a short menu of sorts for actions
    mmp.echo("Stuff you can do:")
    echo("  ")
    echo("Clear all labels ")
    setUnderline(true)
    echoLink("(in area)", 'mmp.clearLabels(' .. areanum .. ')', '', true)
    setUnderline(false)
    echo(" ")
    setUnderline(true)
    echoLink(
      "(whole map)",
      [[
    if not mmp.clearinglabels then
      mmp.echo("Are you sure you want to clear all of your labels on this map? If yes, click the link again.")
      mmp.clearinglabels = true
    else
      mmp.clearLabels("map")
      mmp.clearinglabels = nil
    end
    ]],
      '',
      true
    )
    setUnderline(false)
    echo("\n")
    echo("  ")
    setUnderline(true)
    echoLink(
      "Check for mapper &amp; map updates", 'mmp.echo("Checking...") mmp.checkforupdate()', '', true
    )
    setUnderline(false)
    echo(" ")
    setUnderline(true)
    echoLink(
      "(force map)",
      [[
      if io.exists(getMudletHomeDir().."/map downloads/current") then
        local s,m = os.remove(getMudletHomeDir().."/map downloads/current")
        if not s then mmp.echo("Couldn't delete '"..getMudletHomeDir().."/map downloads/current' file: "..tostring(m)..".") end
      end
      mmp.echo("Re-downloading the latest crowdmap...")
      mmp.checkforupdate()
    ]],
      "Re-download the map regardless if you have latest",
      true
    )
    setUnderline(false)
    echo("\n")
  end

  -- see if we can do anything with the name

  local function handle_name(name)
    local result = mmp.searchRoom(name)
    if type(result) == "string" then
      cecho("&lt;grey&gt;You have no recollection of any room with that name.")
      return
    end
    -- if we got one result, then act on it
    if table.size(result) == 1 then
      if type(next(result)) == "number" then
        handle_number(next(result))
      else
        handle_number(select(2, next(result)))
      end
      return
    end
    -- if not, then ask the user to clarify which one would they want
    mmp.echo("Which room specifically would you like to look up?")
    if not select(2, next(result)) or not tonumber(select(2, next(result))) then
      for roomid, roomname in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
        cechoLink(
          "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
          'mmp.roomLook(' .. roomid .. ')',
          string.format("View room details for %s (%s)", roomid, tostring(roomname)),
          true
        )
        cecho(
          string.format(
            "&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n",
            tostring(mmp.areatabler[getRoomArea(roomid)])
          )
        )
      end
    else
      for roomname, roomid in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
        cechoLink(
          "&lt;" .. mmp.settings.echocolour .. "&gt;" .. roomid,
          'mmp.roomLook(' .. roomid .. ')',
          string.format("View room details for %s (%s)", roomid, tostring(roomname)),
          true
        )
        cecho(
          string.format(
            "&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n",
            tostring(mmp.areatabler[getRoomArea(roomid)])
          )
        )
      end
    end
  end

  if not input then
    if not mmp.roomexists(mmp.currentroom) then
      mmp.echo(mmp.currentroom .. " doesn't seem to be mapped yet.")
      mmp.echo("Stuff you can do:")
      echo("  ")
      echoLink("Check for all updates", 'mmp.echo("Checking...") mmp.checkforupdate()', '')
      echo(" ")
      echoLink(
        "(force map)",
        [[
      local s,m = os.remove(getMudletHomeDir().."/map downloads/current")
        if io.exists(getMudletHomeDir().."/map downloads/current") then
          local s,m = os.remove(getMudletHomeDir().."/map downloads/current")
          if not s then mmp.echo("Couldn't delete '"..getMudletHomeDir().."/map downloads/current' file: "..tostring(m)..".") end
        end
        mmp.echo("Re-downloading the latest map...")
        mmp.checkforupdate()
      ]],
        "Re-download the map regardless if you have latest"
      )
      echo("\n")
      mmp.echo(string.format("version %s.", tostring(mmp.version)))
      return
    else
      input = mmp.currentroom
    end
  end
  if tonumber(input) then
    handle_number(tonumber(input))
  else
    handle_name(input)
  end
  mmp.echo(string.format("version %s.", tostring(mmp.version)))
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp.ferriesfix</name>
						<packageName></packageName>
						<script>function mmp.ferriesfix()
  if table.is_empty(mmp.ferry_rooms) then
    local tmp = getRoomUserData(1, "ferry rooms")
    if tmp ~= "" then
      for _, i in ipairs(yajl.to_value(tmp)) do
        mmp.ferry_rooms[i] = true
      end
    end
  end
end</script>
						<eventHandlerList>
							<string>mmapper updated map</string>
							<string>sysConnectionEvent</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp.wormholesfix</name>
						<packageName></packageName>
						<script>function mmp.wormholesfix()
  local c = 0
  local weight = 10
  for _, area in pairs(getAreaTable()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)

       if exits and next(exits) then
         for exit, cmd in pairs(exits) do
           if type(cmd) == "table" then cmd = next(cmd) end

           if (cmd:lower():find("worm warp", 1, true)) then
				setExitWeight(rooms[i], cmd, weight)
             c = c + 1
           end
         end
       end
    end
  end

  if c &gt; 0 then mmp.echo(string.format("%s wormholes weighted to %s (so we don't take them over too short distances).", c, weight)) end
end</script>
						<eventHandlerList>
							<string>mmapper updated map</string>
							<string>sysMapDownloadEvent</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp.clearlastupdate</name>
						<packageName></packageName>
						<script>function mmp.clearlastupdate()
  -- reset mmp.pdb_lastupdate on the prompt
  enableTrigger"Mudlet Mapper prompt trigger"
end</script>
						<eventHandlerList>
							<string>mmapper updated pdb</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Third-party functions</name>
						<packageName></packageName>
						<script>-- from: http://lua-users.org/wiki/CopyTable
local function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

mmp.deepcopy = deepcopy</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp_regenerate_areas</name>
						<packageName></packageName>
						<script>function mmp_regenerate_areas()
  -- cached data
  mmp.areatable = getAreaTable() -- this translates an area name to an ID
  mmp.areatabler = {} -- this translates an ID to an area name

  local t = getAreaTable()
  for k,v in pairs(t) do
    mmp.areatabler[tonumber(v)] = k
  end

  mmp.clearpathcache()
end</script>
						<eventHandlerList>
							<string>mmp areas changed</string>
							<string>mmapper map reloaded</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp_relock_areas</name>
						<packageName></packageName>
						<script>function mmp_relock_areas()
	local getAreaRooms, lockRoom, lockedareas = getAreaRooms, lockRoom, mmp.locked

	for areaid, areaname in pairs(getAreaTableSwap()) do
		if lockedareas[areaid] then
			local rooms = getAreaRooms(areaid) or {}
			for _, roomid in pairs(rooms) do
				lockRoom(roomid, true)
			end
		else
			local rooms = getAreaRooms(areaid) or {}
			for _, roomid in pairs(rooms) do
				lockRoom(roomid, false)
			end
		end
	end

	-- make sure area with ID 0 is locked - this was causing crashing issues
	local rooms = getAreaRooms(0) or {}
	for _, roomid in pairs(rooms) do
		lockRoom(roomid, true)
	end
end</script>
						<eventHandlerList>
							<string>mmapper map reloaded</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Fix setExit</name>
						<packageName></packageName>
						<script>do
local oldsetExit = setExit

local exitmap = {
  n = 1,
  north = 1,
  ne = 2,
  northeast = 2,
  nw = 3,
  northwest = 3,
  e = 4,
  east = 4,
  w = 5,
  west = 5,
  s = 6,
  south = 6,
  se = 7,
  southeast = 7,
  sw = 8,
  southwest = 8,
  u = 9,
  up = 9,
  d = 10,
  down = 10,
  ["in"] = 11,
  out = 12
}

function setExit(from, to, direction)
  if type(direction) == "string" and not exitmap[direction] then return false end

  return oldsetExit(from, to, type(direction) == "string" and exitmap[direction] or direction)
end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Fix exit locking funcs</name>
						<packageName></packageName>
						<script>do
local oldlockExit = lockExit
local oldhasExitLock = hasExitLock

local exitmap = {
  n = 1,
  north = 1,
  ne = 2,
  northeast = 2,
  nw = 3,
  northwest = 3,
  e = 4,
  east = 4,
  w = 5,
  west = 5,
  s = 6,
  south = 6,
  se = 7,
  southeast = 7,
  sw = 8,
  southwest = 8,
  u = 9,
  up = 9,
  d = 10,
  down = 10,
  ["in"] = 11,
  out = 12
}

function lockExit(from, direction, status)
  if type(direction) == "string" and not exitmap[direction] then return false end

  return oldlockExit(from, type(direction) == "string" and exitmap[direction] or direction, status)
end

function hasExitLock(from, direction)
  if type(direction) == "string" and not exitmap[direction] then return false end

  return oldhasExitLock(from, type(direction) == "string" and exitmap[direction] or direction)
end
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Assorted small utilities</name>
						<packageName></packageName>
						<script>function mmp.comma_value(n) -- credit http://richard.warburton.it
	local left,num,right = string.match(n,'^([^%d]*%d)(%d*)(.-)$')
	return left..(num:reverse():gsub('(%d%d%d)','%1,'):reverse())..right
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Defense tracking</name>
						<packageName></packageName>
						<script>mmp.defs = {current = {}}
mmp.defs.add =
  function()
    local def = gmcp.Char.Defences.Add.name
    if not mmp.defs.current[def] then
      mmp.defs.current[def] = true
      raiseEvent("mmp got def", def)
    end
  end
mmp.defs.remove =
  function()
    for _, def in ipairs(gmcp.Char.Defences.Remove) do
      mmp.defs.current[def] = nil
      raiseEvent("mmp lost def", def)
    end
  end
mmp.defs.list =
  function()
    local newDefs = {}
    local addedDefs, lostDefs = {}, {}
    for _, v in ipairs(gmcp.Char.Defences.List) do
      newDefs[v.name] = true
      if not mmp.defs.current[v.name] then
        addedDefs[#addedDefs + 1] = v.name
      end
    end
    for def in pairs(mmp.defs.current) do
      if not newDefs[def] then
        lostDefs[#lostDefs + 1] = def
      end
    end
    mmp.defs.current = newDefs
    for _, def in pairs(lostDefs) do
      raiseEvent("mmp lost def", def)
    end
    for _, def in ipairs(addedDefs) do
      raiseEvent("mmp got def", def)
    end
  end
-- EVENT HANDLERS
registerAnonymousEventHandler("gmcp.Char.Defences.Add", "mmp.defs.add")
registerAnonymousEventHandler("gmcp.Char.Defences.Remove", "mmp.defs.remove")
registerAnonymousEventHandler("gmcp.Char.Defences.List", "mmp.defs.list")</script>
						<eventHandlerList />
					</Script>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Person tracking</name>
					<packageName></packageName>
					<script>--[[
mmp will have 2 person tracking databases:
- mmp.pdb  =  used to store the last known location of a person
- mmp.pdb_lastupdate  =  used to store the output of the last locating command

Both databases work with the person's name as key and the location name as value.

]]
mmp.pdb = mmp.pdb or {}
mmp.pdb_lastupdate = mmp.pdb_lastupdate or {}

function mmp.is_here(who)
  return (mmp.pdb[who] and mmp.pdb[who] == mmp.currentroomname) and true or false
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Lock Area</name>
					<packageName></packageName>
					<script>-- Lock Area

mmp.locked = mmp.locked or {}
mmp.lastLockSearch = mmp.lastLockSearch or nil

function mmp.doLockArea(search)
	local areaList
	if search ~= nil then
		local r = rex.new(string.lower(search))
		mmp.lastLockSearch = search
		for name, id in pairs(getAreaTable()) do
			if r:match(string.lower(name)) then
				areaList = areaList or {}
				areaList[name] = id
			end
		end
		if areaList == nil then
			mmp.echo("'" .. search .. "' did not match any known areas!")
			return
		end
	else
		mmp.lastLockSearch = nil
		areaList = getAreaTable()
	end

	for name, id in pairs(areaList) do
		mmp.echon(name .. string.rep(" ", 40 - string.len(name)))
		if not mmp.locked[id] then
			setFgColor(0, 200, 0)
			setUnderline(true)
			echoLink("Lock!", [[mmp.lockArea( ']] .. name:gsub("'", [[\']]) .. [[', true )]], "Click to lock area '" .. name .. "'", true)
		else
			setFgColor(200, 0, 0)
			setUnderline(true)
			echoLink("Unlock!", [[mmp.lockArea( ']] .. name:gsub("'", [[\']]) .. [[', false )]], "Click to unlock area '" .. name .. "'", true)
		end
	end

	if not search then
		echo"\n\n" mmp.echo("Use &lt;green&gt;arealock &lt;area&gt;&lt;white&gt; to filter areas.")
	end
end

function mmp.lockArea(name, lock, dontreshow)
	local areas = getAreaTable()
	local rooms = getAreaRooms(areas[name]) or {}
    local lockRoom = lockRoom
    local count = 0
	for _, room in pairs(rooms) do
		lockRoom(room, lock)
        count = count + 1
	end

	mmp.locked[areas[name]] = lock and true or nil
	mmp.echo(string.format("Area '%s' %slocked! All %s room%s within it.", name, (lock and '' or 'un'), count, (count == 1 and '' or 's')))

	if not dontreshow then mmp.doLockArea(mmp.lastLockSearch) end
end


</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Center view via GMCP</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>mmp_center_roominfo</name>
						<packageName></packageName>
						<script>function mmp_center_roominfo()
  -- lusternia has gmcp.Room.Players before gmcp.Room.Info is created
  if msdp.ROOM_VNUM then centerview(msdp.ROOM_VNUM) end
end</script>
						<eventHandlerList>
							<string>gmcp.Room</string>
							<string>gmcp.Room.Info</string>
							<string>msdp.ROOM_VNUM</string>
						</eventHandlerList>
					</Script>
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>mm Mapping</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>mmp_mapping_newroom</name>
						<packageName></packageName>
						<script>--mmp_mapping_newroom

local function makeroom(oldid, newid, x, y, z)
  assert(x and y and z, "makeroom: need all 3 coordinates")
  addRoom(newid)
  setRoomCoordinates(newid, x, y, z)
  setRoomArea(newid, getRoomArea(oldid))
  local fgr, fgg, fgb = unpack(color_table.red)
  local bgr, bgg, bgb = unpack(color_table.blue)
  highlightRoom(newid, fgr, fgg, fgb, bgr, bgg, bgb, 1, 100, 100)
  if mmp.envids[msdp.SECTOR] then
    setRoomEnv(newid, mmp.envids[msdp.SECTOR])
  else
    setRoomEnv(newid, getRoomEnv(oldid))
  end
  return string.format("Created new room %d at %dx,%dy,%dz.", newid, x, y, z)
end

-- gives the reverse shifted coordinates, ie asking for the sw exit + coords will give the coords at ne

local function getshiftedcoords(original, ox, oy, oz)
  local x, y, z
  local has = table.contains
  -- reverse the exit
  w = mmp.ranytolong(original)
  if has({"west", "left", "w", "l"}, w) then
    x = (x or ox) - 1
    y = (y or oy)
    z = (z or oz)
  elseif has({"east", "right", "e", "r"}, w) then
    x = (x or ox) + 1
    y = (y or oy)
    z = (z or oz)
  elseif has({"north", "top", "n", "t"}, w) then
    x = (x or ox)
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({"south", "bottom", "s", "b"}, w) then
    x = (x or ox)
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({"northwest", "topleft", "nw", "tl"}, w) then
    x = (x or ox) - 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({"northeast", "topright", "ne", "tr"}, w) then
    x = (x or ox) + 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({"southeast", "bottomright", "se", "br"}, w) then
    x = (x or ox) + 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({"southwest", "bottomleft", "sw", "bl"}, w) then
    x = (x or ox) - 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({"up", "u"}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) + 1
  elseif has({"down", "d"}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) - 1
  elseif has({"in", "i"}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) - 1
  elseif has({"out", "o"}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) + 1
  else
    mmp.echo(
      "Don't know where to shift the coordinates for a " ..
      tostring(w) ..
      " (" ..
      tostring(original) ..
      ") exit."
    )
  end
  return x, y, z
end

function mmp_mapping_newroom(_, num)
  local s, m =
    xpcall(
      function()
        if not mmp.editing then
          return
        end
        --if not gmcp.Room then
          if not msdp.ROOM_VNUM then
          mmp.echo(
            --"You need to have GMCP turned on (see preferences on a recent Mudlet) for mapping stuff."
            "You need to have msdp turned on (see preferences on a recent Mudlet) for mapping stuff. Also need config msdp on in game"
          )
          return
        end
        -- wilderness mapping right now is UNFINISHED! It does not handle the grid breakup. So, please don't try it, and please won't whine about it.

        local function inwilderness()
          return (msdp.COORDS == "" and msdp.AREA_NAME == "")
        end

        local getRoomName, getRoomCoordinates, getRoomsByPosition =
          getRoomName, getRoomCoordinates, getRoomsByPosition
        --local num = tonumber(num) or tonumber(gmcp.Room.Info.num)
        local num = tonumber(num) or tonumber(msdp.ROOM_VNUM)
        --local currentexits = gmcp.Room.Info.exits
        
        --following strips out the END on the msdp.ROOM_EXITS
        --eotui.cleanUpMsdpExits()
        --info("cleaned up exits")
        local currentexits = msdp.ROOM_EXITS
        
        local s = ""
        if not mmp.roomexists(num) then
          -- see if we can create and link this room with an existing one
          -- wilderness and non-wilderness rooms require different methods of calculating relative coordinates
          if not inwilderness() then
            for exit, id in pairs(currentexits) do
              if mmp.roomexists(id) then
                s = makeroom(id, num, getshiftedcoords(exit, getRoomCoordinates(id)))
              end
            end
          else
            local x, y = tostring(num):match(".-(%d%d%d)(%d%d%d)$")
            -- Achaea's coordinates seem to be in the 4th quadrant, while Mudlets 0,0 is in the middle of the map. Invert y so going north-south looks alright
            s = makeroom(mmp.previousroom, num, x, y * -1, 0)
          end
        end
        -- if we created it, and some data could be filled in
        if mmp.roomexists(num) then
          -- cleanup the room name
          --local rootroomname = mmp.cleanroomname(gmcp.Room.Info.name)
          local rootroomname = mmp.cleanroomname(msdp.ROOM_NAME)
          -- match exact case, so mappers alertness' works properly
          if getRoomName(num) ~= rootroomname then
            setRoomName(num, rootroomname)
            unHighlightRoom(num)
            s = s .. (#s &gt; 0 and " " or "") .. "Updated room name to '" .. rootroomname .. "'."
          end
          -- autolink exits
          if not inwilderness() then
            local x = getRoomExits(num) or {}
            -- check for missing exits
            for exit, id in pairs(currentexits) do
              if id == 0 then
                s =
                  s ..
                  (#s &gt; 0 and " " or "") ..
                  "Can't link to the " ..
                  exit ..
                  ", it leads to a room with ID 0 (and that's not supported yet)."
              else
                if not x[mmp.anytolong(exit)] then
                  if not mmp.roomexists(id) then
                    s =
                      makeroom(
                        num, id, getshiftedcoords(mmp.ranytolong(exit), getRoomCoordinates(num))
                      )
                  end
                  if setExit(num, id, exit) then
                    s =
                      s ..
                      (#s &gt; 0 and " " or "") ..
                      "Added missing exit " ..
                      exit ..
                      " to " ..
                      (getRoomName(id) ~= "" and getRoomName(id) or "''") ..
                      " (" ..
                      id ..
                      ")."
                  else
                    s =
                      s ..
                      (#s &gt; 0 and " " or "") ..
                      string.format(
                        "Failed to link %d withh %d via %s exit for some reason :/", num, id, exit
                      )
                  end
                end
              end
            end
          else
            local function getshiftedcoords(direction, ox, oy, oz)
              if direction == 'n' then
                return ox, oy + 1, oz
              elseif direction == 'e' then
                return ox + 1, oy, oz
              elseif direction == 's' then
                return ox, oy - 1, oz
              elseif direction == 'w' then
                return ox - 1, oy, oz
              elseif direction == 'ne' then
                return ox + 1, oy + 1, oz
              elseif direction == 'se' then
                return ox + 1, oy - 1, oz
              elseif direction == 'sw' then
                return ox - 1, oy - 1, oz
              elseif direction == 'nw' then
                return ox - 1, oy + 1, oz
              else
                error("getshiftedcoords: direction " .. direction .. " isn't supported yet.")
              end
            end

            local x, y, z = getRoomCoordinates(num)
            local currentexits = getRoomExits(num) or {}
            for _, exit in ipairs({'n', 'e', 's', 'w', 'ne', 'se', 'sw', 'nw'}) do
              local roomatdir =
                getRoomsByPosition(getRoomArea(num), getshiftedcoords(exit, x, y, z))
              if roomatdir[0] then
                local id = roomatdir[0]
                if not currentexits[mmp.anytolong(exit)] then
                  if setExit(num, id, exit) then
                    s =
                      s ..
                      (#s &gt; 0 and " " or "") ..
                      "Added missing exit " ..
                      exit ..
                      " to " ..
                      (getRoomName(id) ~= "" and getRoomName(id) or "''") ..
                      " (" ..
                      id ..
                      ")."
                  else
                    s =
                      s ..
                      (#s &gt; 0 and " " or "") ..
                      string.format(
                        "Failed to link %d withh %d via %s exit for some reason :/", num, id, exit
                      )
                  end
                  local exit = mmp.anytoshort(mmp.ranytolong(exit))
                  if setExit(id, num, exit) then
                    s =
                      s ..
                      (#s &gt; 0 and " " or "") ..
                      "Added missing exit " ..
                      exit ..
                      " to " ..
                      (getRoomName(id) ~= "" and getRoomName(id) or "''") ..
                      " (" ..
                      id ..
                      ")."
                  else
                    s =
                      s ..
                      (#s &gt; 0 and " " or "") ..
                      string.format(
                        "Failed to link %d withh %d via %s exit for some reason :/", num, id, exit
                      )
                  end
                end
              end
            end
          end
          -- check for unexisting exits
          if mmp.settings["autoclear"] then
            for exit, id in pairs(getRoomExits(num)) do
              if not currentexits[mmp.anytoshort(exit)] then
                setExit(num, -1, exit)
                s =
                  s ..
                  (#s &gt; 0 and " " or "") ..
                  exit ..
                  " exit to " ..
                  id ..
                  " doesn't actually exist, removed it."
              end
            end
          end
          -- check for environment update, if we have environments mapped out
          if
            --mmp.envids[gmcp.Room.Info.environment] and
            --mmp.envids[gmcp.Room.Info.environment] ~= getRoomEnv(num)
            mmp.envids[msdp.SECTOR] and
            mmp.envids[msdp.SECTOR] ~= getRoomEnv(num)
          then
            --setRoomEnv(num, mmp.envids[gmcp.Room.Info.environment])
            setRoomEnv(num, mmp.envids[msdp.SECTOR])
            s =
              s ..
              (#s &gt; 0 and " " or "") ..
              "Updated environment name to " ..
              --gmcp.Room.Info.environment ..
              msdp.SECTOR ..
              "."
          end
          -- check indoors status
          --local indoors = table.contains(gmcp.Room.Info.details, "indoors")
          --if indoors and getRoomUserData(num, "indoors") == '' then
          --  setRoomUserData(num, "indoors", "y")
          --  s = s .. (#s &gt; 0 and " " or "") .. "Updated room to be indoors."
          --elseif not indoors and getRoomUserData(num, "indoors") ~= '' then
          --  setRoomUserData(num, "indoors", "")
          --  s = s .. (#s &gt; 0 and " " or "") .. "Updated room to be outdoors."
          --end
          -- check server area name (Achaea only for now)
          if mmp.game == "achaea" then
            local serverArea = gmcp.Room.Info.area
            if serverArea ~= getRoomUserData(num, "Game Area") then
              setRoomUserData(num, "Game Area", serverArea)
              s = s .. (#s &gt; 0 and " " or "") .. "Updated game area to " .. serverArea .. "."
            end
          end
          -- check for wilderness exits
          --if getRoomChar(num) ~= "W" and table.contains(gmcp.Room.Info.details, "wilderness") then
          --  setRoomChar(num, "W")
          --  s = s .. (#s &gt; 0 and " " or "") .. "Added the wilderness mark."
          --end
        end
        if #s &gt; 0 then
          mmp.echo(s)
          centerview(mmp.currentroom)
        end
      end,
      function(error)
        mmp.echo("Oops! Has a small problem (" .. error .. ").")
        echo("  ")
        echoLink(
          "view steps",
          'echo[[' .. debug.traceback() .. ']]',
          "View steps of code that led up to it"
        )
      end
    )
  if not s then
    mmp.echo(m)
  end
end</script>
						<eventHandlerList>
							<string>msdp.ROOM_VNUM</string>
							<string>RoomNum</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp_save_options</name>
						<packageName></packageName>
						<script>function mmp_save_options()
	local saveTable = {
		locked_areas = mmp.locked,
		options = mmp.settings:getAllOptions()
	}

	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
	local saveFile = getMudletHomeDir() ..  _sep .. "mapper.options.lua"

	table.save(saveFile, saveTable)
end</script>
						<eventHandlerList>
							<string>sysExitEvent</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>mmp_load_options</name>
						<packageName></packageName>
						<script>function mmp_load_options()
	local loadTable = mmp_load_locks()

	if loadTable.options then
		for k, v in pairs(loadTable.options) do
			mmp.settings:setOption(k, v, true)
		end
	end
end

function mmp_load_locks()
	local loadTable = {}

	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
	local loadFile = getMudletHomeDir() ..  _sep .. "mapper.options.lua"

    if io.exists(loadFile) then table.load(loadFile, loadTable) end

	if loadTable.locked_areas then
		mmp.locked = loadTable.locked_areas
	end

    local lockRoom, getAreaRooms = lockRoom, getAreaRooms
	for area in pairs(mmp.locked) do
		local rooms = getAreaRooms(area)
		for _, roomid in pairs(rooms or {}) do
			lockRoom(roomid, true)
		end
	end

	return loadTable
end</script>
						<eventHandlerList>
							<string>sysLoadEvent</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Environments</name>
						<packageName></packageName>
						<script> mmp.envids =
  {
    air            = 15,
    badland        = 3,
		beach          = 35,
    carriage       = 14,
		cave           = 34,
    city           = 7,
    coast          = 36,
		default        = 1,
    desert         = 11,
    field          = 37,
    forest         = 2,
    ghetto         = 7,
    hills          = 37,
    home           = 4,
    inn            = 4,
    inside         = 7,
    jungle         = 2,
    marsh          = 6,
    mountain       = 36,
    road           = 16,
    ship           = 5,
    shop           = 33,
		temple         = 39,
    tundra         = 38,
		underwater     = 12,
  }

  for name, number in pairs(mmp.envids) do
    mmp.envids[name] = number+256 -- adjust for in-built colors
  end

  --mmp.waterenvs = {}
  --local waterids = { "Underwater"}
  --for i = 1, #waterids do mmp.waterenvs[mmp.envids[waterids[i]]] = true end

  mmp.envidsr = {};
  for name, id in pairs(mmp.envids) do mmp.envidsr[id] = name end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Game-specific</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>Achaea</name>
						<packageName></packageName>
						<script></script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>register_achaeas_envdata</name>
							<packageName></packageName>
							<script>function register_achaeas_envdata(_, game)
  if game ~= "Achaea" then
    return
  end
  mmp.envids =
    {
      ["Constructed underground"] = 2,
      ["Crimson Sea"] = 45,
      ["Deep Ocean"] = 24,
      ["Deep Ocean floor"] = 30,
      ["Dwarven city"] = 18,
      ["Lava Fields"] = 39,
      ["Magma Caves"] = 31,
      ["Natural underground"] = 3,
      ["Ocean floor"] = 34,
      ["Planar Highway"] = 42,
      ["Sanguine River"] = 44,
      ["Tsol'aa city"] = 19,
      ["Vast Ocean"] = 40,
      Abstract = 37,
      Agrarian = 48,
      Ausafoss = 47,
      Beach = 5,
      Blighted = 29,
      Catacombs = 14,
      Chaos = 38,
      Desert = 6,
      Earthen = 43,
      Flames = 49,
      Forest = 4,
      Freshwater = 22,
      Garden = 21,
      Grasslands = 7,
      Hills = 9,
      Jungle = 17,
      Mountains = 14,
      Nothing = 0,
      Ocean = 20,
      Path = 11,
      Polar = 27,
      Reef = 25,
      River = 10,
      Road = 12,
      Ruins = 32,
      Sewer = 23,
      Skies = 10,
      Storm = 50,
      Swamp = 15,
      Trees = 28,
      Tundra = 16,
      Urban = 8,
      Valley = 13,
      Vessel = 36,
      Viscera = 46,
      Wastelands = 41,
      Water = 30,
    }
  mmp.waterenvs = {}
  local waterids =
    {"Freshwater", "Ocean", "River", "Deep Ocean", "Water", "Reef", "Ocean floor", "Vast Ocean"}
  for i = 1, #waterids do
    mmp.waterenvs[mmp.envids[waterids[i]]] = true
  end
  mmp.envidsr = {}
  for name, id in pairs(mmp.envids) do
    mmp.envidsr[id] = name
  end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_achaea_went_outside</name>
							<packageName></packageName>
							<script>-- track whenever we need to use wings or aero soar when we get outside!
function mmapper_achaea_went_outside()
  if not mmp.autowalking or not (mmp.settings.duanathar or mmp.settings.duanatharan or mmp.settings.duantahar or mmp.settings.duanatharic or mmp.settings.soar) or mmp.game ~= "achaea" or
    (mmp.currentroom == mmp.speedWalkPath[#mmp.speedWalkPath]) or
--    table.contains(gmcp.Room.Info.details, "indoors")
    tostring(msdp.SECTOR) == "indoors" or
    tostring(msdp.SECTOR) == "cave"
  then return end

  -- repath, maybe that'll allow us to use wings now.
  raiseEvent("mmp link externals")
	local previousDirection = mmp.speedWalkDir[speedWalkCounter]
	if mmp.speedWalk.type == "room" then
	  mmp.getPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath]) -- don't need to check return value since that fact shouldnt've changed
	else
		mmp.gotoAreaID(getRoomArea(mmp.speedWalkPath[#mmp.speedWalkPath]))
	end

  -- if our path didn't change, re-instate it as it was (since the new path starts from this room that we checked at)
  if speedWalkDir[1]~=previousDirection then
    speedWalkCounter = 0
    mmp.echo("We got outside - going to shortcut with wings.")
		if mmp.speedWalk.type == "room" then
			mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath])
		else
			mmp.gotoAreaID(getRoomArea(mmp.speedWalkPath[#mmp.speedWalkPath]))
		end
    mmp.ignore_speedwalking = true
  end
	raiseEvent("mmp clear externals")
end</script>
							<eventHandlerList>
								<string>mmapper went outside</string>
								<string>mmapper changed continent</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>achaea_gaia_whirlpool_reset</name>
							<packageName></packageName>
							<script>function achaea_gaia_whirlpool_reset(event, game)
	if game == "Achaea" then
		mmp.whirlString = 'script: send("enter whirlpool") if tempWhirlTrigger then killTrigger(tempWhirlTrigger) tempWhirlTrigger = nil end if tempWhirlTimer then killTimer(killWhirlTimer) tempWhirlTimer = nil end tempWhirlTrigger = tempTrigger("What do you wish to enter?", [[if tempWhirlTimer then killTimer(tempWhirlTimer) tempWhirlTimer = nil end mmp.echo("Whirlpool not found here. Trying another room.") local x = {45817, 45780, 45903, 45868, 46254, 45866} if tempWhirlTrigger then killTrigger(tempWhirlTrigger) tempWhirlTrigger = nil end clearSpecialExits(]]..mmp.currentroom..[[) local y = table.index_of(x, ]]..mmp.currentroom..[[) + 1 if y &gt; #x then y = 1 end addSpecialExit(x[y], 793, mmp.whirlString) mmp.clearpathcache() mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath]) mmp.echo("Moved whirlpool to "..x[y]..".")]]) tempWhirlTimer = tempTimer(1, [[if tempWhirlTrigger then killTrigger(tempWhirlTrigger) tempWhirlTrigger = nil end if tempWhirlTimer then killTimer(tempWhirlTimer) tempWhirlTimer = nil end]])'
		local x = {45817, 45780, 45903, 45868, 46254, 45866}
		for i, v in ipairs(x) do clearSpecialExits(v) end
		addSpecialExit(45868, 793, mmp.whirlString)
	end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_achaea_went_outside_harness</name>
							<packageName></packageName>
							<script>-- use Stratospheric Harness in Achaea -- PapaGuacamole
	
function mmapper_achaea_went_outside_harness()

	local area = mmp.getAreaName(mmp.currentroom)
	local areaid = getRoomArea(mmp.currentroom)
  if not mmp.autowalking or not mmp.settings.harness or not (mmp.game == "achaea") or
    (mmp.currentroom == mmp.speedWalkPath[#mmp.speedWalkPath]) or
 --   table.contains(gmcp.Room.Info.details, "indoors") or
    tostring(msdp.SECTOR) == "indoors" or
    tostring(msdp.SECTOR) == "cave" or
    (not mmp.oncontinent(areaid, "Eastern_Isles") and not mmp.oncontinent(areaid, "Northern_Isles") and not mmp.oncontinent(areaid, "Western_Isles"))
		then return end

	local madeEast, madeNorth, madeWest

 	-- eastern isles
 	if mmp.oncontinent(areaid, "Eastern_Isles") then
 		addSpecialExit(mmp.currentroom, 54231, [[script:send("shake harness")]])
 		mmp.clearpathcache() -- clear cache so mmp.getPath accounts for the new way
 		madeEast = true
 	-- northern isles
 	elseif mmp.oncontinent(areaid, "Northern_Isles") then
 		addSpecialExit(mmp.currentroom, 48719, [[script:send("shake harness")]])
 		mmp.clearpathcache() -- clear cache so mmp.getPath accounts for the new way
 		madeNorth = true
 	-- western isles
 	elseif mmp.oncontinent(areaid, "Western_Isles") then
 		addSpecialExit(mmp.currentroom, 54632, [[script:send("shake harness")]])
 		mmp.clearpathcache() -- clear cache so mmp.getPath accounts for the new way
 		madeWest = true
 	end

	mmp.getPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath]) -- don't need to check return value since that fact shouldnt've changed
	-- if our path didn't change, re-instate it as it was (since the new path starts from this room that we checked at)
	if speedWalkDir[1]:find("harness", 1, true) then
	speedWalkCounter = 0
		mmp.echo("We got outside - going to shortcut with harness.")
		if mmp.speedWalk.type == "room" then
			mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath])
		else
			mmp.gotoAreaID(getRoomArea(mmp.speedWalkPath[#mmp.speedWalkPath]))
		end
		mmp.ignore_speedwalking = true
 	end
	
  if madeEast then mmp.clearspecials{54231}
  elseif madeNorth then mmp.clearspecials{48719}
  elseif madeWest then mmp.clearspecials{54632} end

end</script>
							<eventHandlerList>
								<string>mmapper went outside</string>
								<string>mmapper changed continent</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Shackle handling</name>
							<packageName></packageName>
							<script>local density = false
--Wear shackle function

function mmp.WearShackle()
  if mmp.settings.shackle and density then
    send("wear shackle")
  end
end

function mmp.UnwearShackle()
  if mmp.settings.shackle and mmp.defs.current.density then
    density = true
    send("remove shackle")
  elseif not mmp.defs.current.density then
    density = false
  end
end

--Event Handlers
registerAnonymousEventHandler("mmapper failed path", "mmp.WearShackle")
registerAnonymousEventHandler("mmapper stopped", "mmp.WearShackle")
registerAnonymousEventHandler("mmapper arrived", "mmp.WearShackle")
registerAnonymousEventHandler("started speedwalk", "mmp.UnwearShackle")</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_achaea_orb_of_confinement</name>
							<packageName></packageName>
							<script>function mmp.setOrb(city)
  mmp.clearpathcache()
  if mmp.settings["orb"..city:lower()] then
    mmp.echo("Orb of Confinement set as &lt;green&gt;ACTIVE&lt;reset&gt; for " .. city:title())
  else
    mmp.echo("Orb of Confinement set as &lt;red&gt;INACTIVE&lt;reset&gt; for " .. city:title())
  end
end

function mmapper_achaea_orb_of_confinement()

  if
    not mmp.autowalking or
    not (
      mmp.settings.duanathar or
      mmp.settings.duanatharan or
      mmp.settings.duantahar or
      mmp.settings.duanatharic or
      mmp.settings.soar
    ) or
    not (mmp.game == "achaea") or
    (mmp.currentroom == mmp.speedWalkPath[#mmp.speedWalkPath]) or
    table.contains(gmcp.Room.Info.details, "indoors") or
    tostring(msdp.SECTOR) == "indoors" or
    tostring(msdp.SECTOR) == "cave" or
    not mmp.orbed()
  then
    return
  end
  -- repath, just in case we were going to use wings here
  raiseEvent("mmp link externals")
  local previousDirection = mmp.speedWalkDir[speedWalkCounter+1]
  if mmp.speedWalk.type == "room" then
    mmp.getPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath])
    -- don't need to check return value since that fact shouldnt've changed
  else
    mmp.gotoAreaID(getRoomArea(mmp.speedWalkPath[#mmp.speedWalkPath]))
  end
  -- if our path didn't change, re-instate it as it was (since the new path starts from this room that we checked at)
  if speedWalkDir[1] ~= previousDirection then
    speedWalkCounter = 0
    mmp.echo("We're inside, remapping path to not use wings here.")
    if mmp.speedWalk.type == "room" then
      mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath])
    else
      mmp.gotoAreaID(getRoomArea(mmp.speedWalkPath[#mmp.speedWalkPath]))
    end
    mmp.ignore_speedwalking = true
  end
  raiseEvent("mmp clear externals")
end</script>
							<eventHandlerList>
								<string>mmapper went inside</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_achaea_harness_add_exits</name>
							<packageName></packageName>
							<script>function mmapper_achaea_harness_add_exits()
  if not (mmp.game == "achaea" and mmp.settings.harness) then
    return
  end
	local cmd = [[script:send("shake harness",false)]]
  local areaID = getRoomArea(mmp.currentroom) or 0
  if mmp.oncontinent(areaID, "Eastern_Isles") then
    if not mmp.inside then
      -- make it here
      addSpecialExit(mmp.currentroom, 54231, cmd)
    elseif areaID == 192 then
      -- Zanzibaar
      addSpecialExit(31215, 54231, cmd)
    elseif areaID == 191 then
      -- Clockwork Isle
      addSpecialExit(23351, 54231, cmd)
    elseif areaID == 180 then
      -- Colchis, the Isle of
      addSpecialExit(19786, 54231, cmd)
    else
      --if areaID == 181 then -- Umbrin, the Port of
      addSpecialExit(18443, 54231, cmd)
    end
    --madeEast = true
  elseif mmp.oncontinent(areaID, "Northern_Isles") then
    if not mmp.inside then
      -- make it here
      addSpecialExit(mmp.currentroom, 48719, cmd)
    elseif areaID == 194 then
      -- Ilyrean
      addSpecialExit(13373, 48719, cmd)
    elseif areaID == 351 then
      -- Karbaz
      addSpecialExit(19740, 48719, cmd)
    else
      --if areaID == 206 or getRoomArea(mmp.currentroom) = 294 then -- Suliel Island / Suliel Island (Barricades)
      addSpecialExit(17768, 48719, cmd)
    end
  elseif mmp.oncontinent(areaID, "Western_Isles") then
    if not mmp.inside then
      -- make it here
      addSpecialExit(mmp.currentroom, 54632, cmd)
    elseif areaID == 162 then
      --Tapoa
      addSpecialExit(21184, 54632, cmd)
    elseif areaID == 207 then
      --Tuar
      addSpecialExit(19219, 54632, cmd)
    else
      --if areaID == 209 then --Ageiro
      addSpecialExit(30222, 54632, cmd)
    end
  end
end</script>
							<eventHandlerList>
								<string>mmp link externals</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_achaea_harness_remove_exits</name>
							<packageName></packageName>
							<script>function mmapper_achaea_harness_remove_exits()
  local areaID = getRoomArea(mmp.currentroom) or 0
  if not (mmp.game == "achaea" and mmp.settings.harness) then
    return
  end
  if mmp.oncontinent(areaID, "Eastern_Isles") then
    mmp.clearspecials({54231})
  elseif mmp.oncontinent(areaID, "Northern_Isles") then
    mmp.clearspecials({48719})
  elseif mmp.oncontinent(areaID, "Western_Isles") then
    mmp.clearspecials({54632})
  end
end</script>
							<eventHandlerList>
								<string>mmp clear externals</string>
							</eventHandlerList>
						</Script>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Aetolia</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>register_aetolias_envdata</name>
							<packageName></packageName>
							<script>function register_aetolias_envdata(_, game)
  if game ~= "Aetolia" then return end

  mmp.envids =
  {
    ["a bridge"]                = 55,
    ["Airship wreckage"]        = 62,
    ["camp site"]               = 57,
    ["Constructed underground"] = 2,
    ["Deep ocean"]              = 24,
    ["lifeless sands"]          = 54,
    ["logged forest"]           = 56,
    ["Natural underground"]     = 3,
    ["Tsol'aa city"]            = 19,
    ["Underwater city"]         = 28,
    ["within a tree"]           = 36,
    Beach                       = 5,
    Canyon                      = 34,
    Castle                      = 61,
    Cavern                      = 69,
    Chaos                       = 1,
    Crater                      = 37,
    Desert                      = 6,
    Ethereal                    = 67,
    Forest                      = 4,
    Freshwater                  = 22,
    Garden                      = 21,
    Grasslands                  = 7,
    Graveyard                   = 31,
    grotto                      = 70,
    Hills                       = 9,
    Ice                         = 30,
    Jungle                      = 17,
    lava                        = 39,
    Mines                       = 32,
    Mountains                   = 14,
    Ocean                       = 20,
    Onboard                     = 33,
    Path                        = 11,
    Reef                        = 25,
    River                       = 10,
    Road                        = 12,
    Ruins                       = 26,
    Sewer                       = 23,
    Shadows                     = 58,
    Swamp                       = 15,
    Temple                      = 29,
    Tundra                      = 16,
    Urban                       = 8,
    Valley                      = 13,
    Village                     = 27,
  }

  mmp.waterenvs = {}
  local waterids = { "River", "Freshwater", "Deep ocean", "Reef", "Underwater city" }
  for i = 1, #waterids do mmp.waterenvs[mmp.envids[waterids[i]]] = true end

  mmp.envidsr = {};
  for name, id in pairs(mmp.envids) do mmp.envidsr[id] = name end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Lusternia</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>register_lusternias_envdata</name>
							<packageName></packageName>
							<script>function register_lusternias_envdata(_, game)
  if game ~= "Lusternia" then return end

  mmp.envids =
  {
    ["constructed underground"] = 2,
    ["deep ocean"]              = 24,
    ["natural underground"]     = 3,
    aether                      = 36,
    astral                      = 35,
    beach                       = 5,
    chaos                       = 39,
    clouds                      = 37,
    concordance                 = 38,
    darkness                    = 1,
    desert                      = 6,
    divine                      = 33,
    farmlands                   = 30,
    flesh                       = 18,
    forest                      = 4,
    freshwater                  = 22,
    garden                      = 21,
    grasslands                  = 7,
    hills                       = 9,
    jungle                      = 17,
    mountains                   = 14,
    netherworld                 = 34,
    ocean                       = 20,
    path                        = 11,
    polar                       = 27,
    reef                        = 25,
    river                       = 10,
    road                        = 12,
    ruins                       = 19,
    sewer                       = 23,
    swamp                       = 15,
    trees                       = 28,
    tundra                      = 16,
    urban                       = 8,
    valley                      = 13,
    volcanic                    = 32,
    wasteland                   = 29,
  }

  mmp.waterenvs = {}
  local waterids = { "river", "ocean", "freshwater", "deep ocean" }
  for i = 1, #waterids do mmp.waterenvs[mmp.envids[waterids[i]]] = true end

  mmp.envidsr = {};
  for name, id in pairs(mmp.envids) do mmp.envidsr[id] = name end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_lusternia_went_outside</name>
							<packageName></packageName>
							<script>function mmapper_lusternia_went_outside()
  -- track whenever we need to use items when we get outside!
  if
    not mmp.autowalking or
    mmp.game ~= "lusternia" or
    (mmp.currentroom == mmp.speedWalkPath[#mmp.speedWalkPath])
  then
    return
  end
  -- repath, maybe that'll allow us to use wings now.
  raiseEvent("mmp link externals")
	local previousDirection = mmp.speedWalkDir[speedWalkCounter]
  mmp.getPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath])
  -- don't need to check return value since that fact shouldnt've changed
  -- if our path didn't change, re-instate it as it was (since the new path starts from this room that we checked at)
  if
    speedWalkDir[1]~=previousDirection
  then
    speedWalkCounter = 0
    mmp.echo("We got outside - going to shortcut with 'bix device.")
		if mmp.speedWalk.type == "room" then
			mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath])
		else
			mmp.gotoAreaID(getRoomArea(mmp.speedWalkPath[#mmp.speedWalkPath]))
		end
    mmp.ignore_speedwalking = true
  end
  raiseEvent("mmp clear externals")
end</script>
							<eventHandlerList>
								<string>mmapper went outside</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Astral utilities</name>
							<packageName></packageName>
							<script>local astralExits = {
	{5079,5175,"n"},
	{4072,5065,"w"},
	{5088, 5132, "e"},
	{5145, 5176, "s"},
	{5138, 5146, "e"},
	{5158, 5192, "s"},
	{5152, 5041, "e"},
	{5031, 5042, "e"},
	{5022, 5131, "n"},
	{5116, 5198, "w"},
	{5130, 5096, "e"},
	{5089, 5058, "n"},
	{5102, 5115, "e"},
	{5111, 5159, "e"},	
	{5103, 5071, "n"},
	{5059, 5053, "w"},
	{5187, 5169, "w"},
	{5190, 5204, "e"},
	{5065,5072,"e"},
}
local mirrorExits = {
	n="s",
	ne="sw",
	e="w",
	se="nw",
	s="n",
	sw="ne",
	w="e",
	nw="se",
	u="d",
	d="u",
	out="in",
	["in"]="out",
}
function mmp.astroboots(create)
	if mmp.game ~= "lusternia" then return end
	for k, v in pairs(astralExits) do
		if create then
			addSpecialExit(v[1],v[2],"astrojump")
			setExitWeight(v[1],"astrojump",5)
			addSpecialExit(v[2],v[1],"astrojump")
			setExitWeight(v[2],"astrojump",5)
		else
			removeSpecialExit(v[1],"astrojump")
			removeSpecialExit(v[2],"astrojump")
		end
	end
end

function mmp.wildnodes(create)
	if mmp.game ~= "lusternia" then return end
	for k, v in pairs(astralExits) do
		if create then
			setExit(v[1],v[2],v[3])
			setExit(v[2],v[1],mirrorExits[v[3]])
		else
			setExit(v[1],-1,v[3])
			setExit(v[2],-1,mirrorExits[v[3]])
		end
	end
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Transverse and pathfind</name>
							<packageName></packageName>
							<script>local planes =
  {
    ["the Prime Material Plane"] = "prime",
    ["the Ethereal Plane"] = "ethereal",
    ["the Water Elemental Plane"] = "elemental",
    ["the Earth Elemental Plane"] = "elemental",
    ["the Air Elemental Plane"] = "elemental",
    ["the Fire Elemental Plane"] = "elemental",
    ["Celestia, Plane of Light"] = "cosmic",
    ["the Cosmic Plane of Vortex"] = "cosmic",
    ["the Cosmic Plane of Continuum"] = "cosmic",
    ["the Tainted Plane of Nil"] = "cosmic",
    ["the Astral Plane"] = "astral",
  }

function mmp.transverse(_, command)
  command = command:lower()
  if command:sub(0, 11) == "transverse " or command == "pathfind" then
    transverseCMD = command
    transversedFrom = gmcp.Room.Info.num
    lastPlane = planes[gmcp.Room.Info.details[1]]
    validTransverse = true
  end
end

registerAnonymousEventHandler("sysDataSendRequest", "mmp.transverse")

function mmp.registerTransverseExit()
  if transversedFrom ~= gmcp.Room.Info.num then
    addSpecialExit(transversedFrom, gmcp.Room.Info.num, transverseCMD)
    setExitWeight(transversedFrom, transverseCMD, 20)
    if lastPlane then
      addSpecialExit(gmcp.Room.Info.num, transversedFrom, "transverse " .. lastPlane)
      setExitWeight(gmcp.Room.Info.num, "transverse " .. lastPlane, 20)
    end
    validTransverse = false
  end
end

function mmp.clearTransverse()
  local otherSide = 0
  for room, command in pairs(getSpecialExits(gmcp.Room.Info.num)) do
    if next(command) == transverseCMD then
      otherSide = room
    end
  end
  for room, command in pairs(getSpecialExits(otherSide) or {}) do
    if room == gmcp.Room.Info.num and string.sub(next(command), 0, 11) == "transverse " then
      removeSpecialExit(otherSide, next(command))
    end
  end
  removeSpecialExit(gmcp.Room.Info.num, transverseCMD)
  if mmp.autowalking then
    mmp.autowalking = false
    mmp.gotoRoom(string.split(next(mmp.showpathcache()), "_")[2])
  end
end

function mmp.registerPathfind()
  addSpecialExit(transversedFrom, gmcp.Room.Info.num, "pathfind")
  setExitWeight(transversedFrom, "pathfind", 15)
  addSpecialExit(gmcp.Room.Info.num, transversedFrom, "pathfind")
  setExitWeight(gmcp.Room.Info.num, "pathfind", 15)
  validTransverse = false
end

function mmp.clearPathfind()
  local otherSide = 0
  for room, command in pairs(getSpecialExits(gmcp.Room.Info.num)) do
    if next(command) == "pathfind" then
      otherSide = room
    end
  end
  for room, command in pairs(getSpecialExits(otherSide) or {}) do
    if room == gmcp.Room.Info.num and next(command) == "pathfind" then
      removeSpecialExit(otherSide, next(command))
    end
  end
  removeSpecialExit(gmcp.Room.Info.num, "pathfind")
  if mmp.autowalking then
    mmp.autowalking = false
    mmp.gotoRoom(string.split(next(mmp.showpathcache()), "_")[2])
  end
end

function mmp.lockpaths(lock)
  local count = 0
  for area, areaname in pairs(mmp.areatabler) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      for room, command in pairs(exits or {}) do
        if next(command) == "pathfind" then
          count = count + 1
          lockSpecialExit(rooms[i], room, "pathfind", lock)
        end
      end
    end
  end
  mmp.echo((lock and "Locked " or "Unlocked ") .. count .. " pathfinding exits.")
end</script>
							<eventHandlerList />
						</Script>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Imperian</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>register_imperians_envdata</name>
							<packageName></packageName>
							<script>function register_imperians_envdata(_, game)
  if game ~= "Imperian" then return end
  mmp.envids =
  {
    ["a sheltered dell"]        = 68,
    ["Arcane Temple"]           = 66,
    ["Blackened Lands"]         = 58,
    ["Blackstone Dungeon"]      = 65,
    ["Blackstone Keep"]         = 62,
    ["Constructed underground"] = 2,
    ["Dark Forest"]             = 1,
    ["Deep Ocean"]              = 24,
    ["Desert Ruins"]            = 38,
    ["Dwarven city"]            = 18,
    ["Forestal Council"]        = 44,
    ["Frozen Bog"]              = 76,
    ["Lake of Fire"]            = 56,
    ["Natural underground"]     = 3,
    ["Noble Bar"]               = 53,
    ["Noble Chambers"]          = 51,
    ["Rocky Shore"]             = 77,
    ["Sylayan city"]            = 19,
    ["Tainted Underground"]     = 35,
    ["Tainted Water"]           = 39,
    ["Underground Lake"]        = 36,
    ["Vast Ocean"]              = 26,
    ["Wetlands Village"]        = 64,
    ["within a tent"]           = 69,
    Academia                    = 42,
    Acropolis                   = 33,
    Beach                       = 5,
    Blighted                    = 74,
    bog                         = 73,
    Catacombs                   = 63,
    Church                      = 54,
    Cliffs                      = 67,
    Crags                       = 32,
    Desert                      = 6,
    Docks                       = 30,
    Farmland                    = 41,
    Forest                      = 4,
    Freshwater                  = 22,
    Garden                      = 21,
    garrison                    = 71,
    Grasslands                  = 7,
    Graveyard                   = 46,
    Hills                       = 9,
    Jungle                      = 17,
    Mountains                   = 14,
    Nobility                    = 50,
    Ocean                       = 20,
    Path                        = 11,
    Polar                       = 27,
    Pond                        = 49,
    pyramid                     = 72,
    quarry                      = 70,
    River                       = 10,
    Road                        = 12,
    Ruins                       = 37,
    Scrublands                  = 78,
    Sewer                       = 23,
    Swamp                       = 15,
    Temple                      = 57,
    Tower                       = 79,
    transportation              = 48,
    Tundra                      = 16,
    Underworld                  = 28,
    Urban                       = 8,
    Valley                      = 13,
    Villa                       = 75,
    Village                     = 47,
    Village                     = 55,
    Volcano                     = 59,
    Warrens                     = 31,
  }

  mmp.waterenvs = {}
  local waterids = { "River", "Ocean", "Deep Ocean", "Vast Ocean", "Underground Lake", "Tainted Water", "Lake of Fire" }
  for i = 1, #waterids do mmp.waterenvs[mmp.envids[waterids[i]]] = true end

  mmp.envidsr = {};
  for name, id in pairs(mmp.envids) do mmp.envidsr[id] = name end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>mmapper_imperian_went_outside</name>
							<packageName></packageName>
							<script>function mmapper_imperian_went_outside()
  if
    not mmp.autowalking or
    not (mmp.settings.shekinah or mmp.settings.suriel) or
    mmp.game ~= "imperian" or
    (mmp.currentroom == mmp.speedWalkPath[#mmp.speedWalkPath]) or
 --   table.contains(gmcp.Room.Info.details, "indoors") or
 --   table.contains(gmcp.Room.Info.details, "considered indoors") or
      tostring(msdp.SECTOR) == "indoors" or
    tostring(msdp.SECTOR) == "cave" or
    not table.contains(mmp.imperian.wingAbleAreas, getRoomArea(mmp.currentroom))
  then
    return
  end
  -- repath, maybe that'll allow us to use wings now.
  raiseEvent("mmp link externals")
  local previousDirection = mmp.speedWalkDir[speedWalkCounter]
  mmp.getPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath])
  -- don't need to check return value since that fact shouldnt've changed
  -- if our path didn't change, re-instate it as it was (since the new path starts from this room that we checked at)
  if speedWalkDir[1] ~= previousDirection then
    speedWalkCounter = 0
    mmp.echo("We got outside - going to shortcut with wings.")
    mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath])
    mmp.ignore_speedwalking = true
  end
  raiseEvent("mmp clear externals")
end</script>
							<eventHandlerList>
								<string>mmapper went outside</string>
								<string>mmapper changed continent</string>
							</eventHandlerList>
						</Script>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Starmourn</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Lifts</name>
							<packageName></packageName>
							<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function mmp.liftFloor(roomname,floornum,currentfloor) --string,int,bool
	if not mmp.autowalking then
		return
	end

	--get room name of next in speedwalkpath
	if not speedWalkCounter then
    speedWalkCounter = 1
  end
	local destRoomName = getRoomName(mmp.speedWalkPath[speedWalkCounter])
	if roomname == nil then roomname = destRoomName end

	if roomname == destRoomName then
		if currentfloor then
			send("EXIT LIFT",false) --Lift is on correct floor, can EXIT LIFT
			if mmp.liftTimer then killTimer(mmp.liftTimer) end
		else
			mmp.customwalkdelay(2) --Lift is on incorrect floor arbitrary wait for next trigger line
			if mmp.liftTimer then killTimer(mmp.liftTimer) end
			mmp.liftTimer = tempTimer(1, function() send("KEY LIFT ".. floornum,false) end )	--wait one second before requesting the correct floor (allows other users to enter/exit)
		end
	end
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>register_starmourn_envdata</name>
							<packageName></packageName>
							<script>function register_starmourn_envdata(_, game)
  if game ~= "Starmourn" then
    return
  end
  mmp.envids =
    {
      ["airlock"] = 55,
      ["alleyway"] = 47,
      ["armory"] = 82,
      ["badlands"] = 45,
      ["barracks"] = 77,
      ["bathroom"] = 71,
      ["beach"] = 51,
      ["bedroom"] = 66,
      ["bridge"] = 18,
      ["building"] = 5,
      ["campsite"] = 65,
      ["canal"] = 85,
      ["cantina"] = 62,
      ["canyon"] = 31,
      ["cargo bay"] = 13,
      ["catwalk"] = 23,
      ["cave"] = 37,
      ["commandpost"] = 80,
      ["corral"] = 34,
      ["deep space"] = 11,
      ["desert"] = 7,
      ["duct"] = 22,
      ["engine room"] = 44,
      ["factory"] = 32,
      ["farmland"] = 28,
      ["firingrange"] = 83,
      ["forest"] = 8,
      ["garden"] = 12,
      ["gym"] = 60,
      ["hallway"] = 58,
      ["hangar"] = 26,
      ["hangar"] = 79,
      ["hydroponics"] = 61,
      ["icyforest"] = 52,
      ["jungle"] = 19,
      ["junkyard"] = 48,
      ["lake"] = 49,
      ["lava fields"] = 56,
      ["lava"] = 57,
      ["meadow"] = 30,
      ["medical facility"] = 17,
      ["medical facility"] = 27,
      ["messhall"] = 78,
      ["militarybase"] = 76,
      ["militaryroad"] = 81,
      ["mine"] = 3,
      ["mountain"] = 1,
      ["obstaclecourse"] = 84,
      ["ocean"] = 6,
      ["office"] = 15,
      ["pier/dock"] = 38,
      ["pond"] = 64,
      ["pool"] = 14,
      ["prison"] = 59,
      ["residence"] = 63,
      ["river"] = 50,
      ["road"] = 29,
      ["ruin"] = 42,
      ["sewer"] = 40,
      ["shop"] = 67,
      ["slum"] = 69,
      ["slumbuilding"] = 73,
      ["slumstreet"] = 70,
      ["slumtoilet"] = 72,
      ["spacecraft"] = 9,
      ["spaceport"] = 39,
      ["stateroom"] = 43,
      ["stream"] = 35,
      ["street"] = 2,
      ["swamp"] = 20,
      ["temple"] = 54,
      ["transport"] = 16,
      ["treehouse"] = 36,
      ["treetops"] = 53,
      ["tundra"] = 10,
      ["underground"] = 86,
      ["underwater"] = 87,
      ["urban"] = 4,
      ["urbanunderground"] = 46,
      ["ventilation shaft"] = 21,
      ["verdantcliffs"] = 75,
    }
  mmp.waterenvs = {}
  mmp.envidsr = {}
  for name, id in pairs(mmp.envids) do
    mmp.envidsr[id] = name
  end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Lithmeria</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>register_lithmerias_envdata</name>
							<packageName></packageName>
							<script>function register_lithmerias_envdata(_, game)
  if game ~= "Lithmeria" then return end

  mmp.envids =
  {
    ["deep water"] = 4,
    beach          = 11,
    bridge         = 6,
    building       = 13,
    cliffs         = 1,
    desert         = 11,
    forest         = 2,
    highway        = 6,
    jungle         = 10,
    mountain       = 1,
    ocean          = 4,
    path           = 6,
    plains         = 3,
    river          = 4,
    road           = 6,
    shallowwater   = 4,
    swamp          = 2,
    tundra         = 7,
    underground    = 8,
    urban          = 8,
    water          = 4,
  }

  for name, number in pairs(mmp.envids) do
    mmp.envids[name] = number+256 -- adjust for in-built colors
  end

  mmp.waterenvs = {}
  local waterids = { "shallowwater", "river", "water", "deep water", "ocean" }
  for i = 1, #waterids do mmp.waterenvs[mmp.envids[waterids[i]]] = true end

  mmp.envidsr = {};
  for name, id in pairs(mmp.envids) do mmp.envidsr[id] = name end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Test / one-time things</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="no" isFolder="no">
						<name>mmp_grabenvid</name>
						<packageName></packageName>
						<script>function mmp_grabenvid()
  if not mmp.envids[msdp.SECTOR] then
    mmp.envids[msdp.SECTOR] = getRoomEnv(mmp.currentroom)
    mmp.echo(string.format("Remembered environment %s as %d", msdp.SECTOR, mmp.envids[msdp.SECTOR]))
  end
end

function mmp.getMaxID()
  local roomIDs = {}
  for area, _ in pairs(mmp.areatabler) do
    local ok, t = pcall(getAreaRooms, area)
    if ok then
      for _, id in pairs(t or {}) do
        roomIDs[id] = true
      end
    end
  end

  return table.maxn(roomIDs)
end

function mmp.getUnknownEnvs()
  local maxid, missing = mmp.getMaxID(), {}

  for i = 1, maxid do
    if mmp.roomexists(i) then
      if not table.contains(mmp.envids, getRoomEnv(i)) and not table.contains(missing, getRoomEnv(i)) then
        mmp.echo(string.format("Missing env %d from room %d ('%s' in '%s')",
          tostring(getRoomEnv(i)), i, tostring(getRoomName(i)), tostring(mmp.areatabler[getRoomArea(i)])))
        missing[i] = getRoomEnv(i)
      end
    end
  end
end</script>
						<eventHandlerList>
							<string>gmcp.Room.Info</string>
							<string>msdp.ROOM_VNUM</string>
							<string>msdp.SECTOR</string>
						</eventHandlerList>
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Check for map updates</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>mmp_downloaded_file</name>
						<packageName></packageName>
						<script>function mmp_downloaded_file(_, filename)
  if not io.exists(filename) then return end

  -- workaround for https://bugs.launchpad.net/mudlet/+bug/1092769
--  if mmp["downloaded_file_block_"..filename] then return end
--  mmp["downloaded_file_block_"..filename] = tempTimer(5, [[mmp["downloaded_file_block_]]..filename..[["] = nil]])

  if filename == tostring(mmp.mapperfile) then   -- mapper script version
	mmp.checkingupdates = false

    local f, s = io.open(filename)
    if f then s = f:read("*l"):trim(); io.close(f) end

    if s ~= tostring(mmp.version) then
      mmp.newmapperversion = s
      mmp.retrievechangelog()
    end

  elseif filename == tostring(mmp.changelogfile) then   -- changelog for the mapper script
	mmp.checkingupdates = false

    local f, s, changelog = io.open(filename)
    if f then changelog = f:read("*a"); io.close(f) end

    mmp.echon("")
    echoLink("The mapper script was updated! Would you like to download the update? Click here if so.", "mmp.downloadmapperscript()", "Changelog for the latest ("..tostring(mmp.version).." -&gt; "..tostring(mmp.newmapperversion)..") update:\n"..changelog, true)

  elseif filename == mmp.crowdchangelogfile then   -- changelog for the crowdmap
    local f, s = io.open(filename)
    if f then s = f:read("*a"); io.close(f) end

    -- make environment
    local env = {} -- add functions you know are safe here

    -- run code under environment [Lua 5.1]
    local function run(untrusted_code)
      if untrusted_code:byte(1) == 27 then return nil, "binary bytecode prohibited" end
      local untrusted_function, message = loadstring(untrusted_code)
      if not untrusted_function then return nil, message end
      setfenv(untrusted_function, env)
      return pcall(untrusted_function)
    end

    run(s)

	mmp.crowdchangelog = env.changelog

    mmp.echon("The crowdmap map was ")
    setUnderline(true)
    echoLink("updated", '', "New version: "..tostring(mmp.newversion)..", previous version: "..(mmp.oldversion or "(none)"), true)
    setUnderline(false)
    echo(" (")
    setUnderline(true)
    echoLink("see full changelog", "mmp.showcrowdchangelog()", 'View the full changelog for mappers', true)
    setUnderline(false)
    echo("). Latest improvement is: "..tostring(mmp.crowdchangelog and mmp.crowdchangelog[#mmp.crowdchangelog] or '?')..".\n")

    mmp.downloadcrowdmap(mmp.newversion)

  elseif filename == mmp.crowdmapfile then    -- crowdmap map
    mmp.echo("Map downloaded, loading it in...")

    local tmp = getRoomUserData(1, "gotoMapping")
    local oldmaptable = {}

    if tmp ~= "" then
      oldmaptable = yajl.to_value(tmp)
    end

    local ok = loadMap(filename)

    if ok then
      if mmp.game ~= "starmourn" then
        local wc = mmp.lockWormholes()
  	local ws = mmp.lockSewers()
        mmp.lockPebble()
        if mmp.game == "achaea" and wc == 0 and ws == 0 then -- in achaea, using crowdmap, if we didn't get any special exits - it means Mudlet needs to be updated
          mmp.echo("Sorry, it seems your Mudlet isn't compatible with the new crowdmap format - and the map cannot be loaded fully. Please update your Mudlet:\n  http://www.mudlet.org/download/")
          return
        end
      end

      if mmp.settings.waterwalk then mmp.enableWaterWalk() else mmp.disableWaterWalk() end

      mmp.echo("Map loaded fine - enjoy!")

      tmp = getRoomUserData(1, "gotoMapping")
      local newmaptable = {}

      if tmp ~= "" then
        newmaptable = yajl.to_value(tmp)
      end

      for k,v in pairs(oldmaptable) do newmaptable[k] = v end
      setRoomUserData(1, "gotoMapping", yajl.to_string(newmaptable))
      mmp.echo("Marks from the old map migrated successfully.")

      raiseEvent("mmapper updated map")
    else
      mmp.echon("Map failed to load - you need to have the mapper open. Please open it, and then ")
      echoLink("click here", [[
        local tmp = getRoomUserData(1, "gotoMapping")
        local oldmaptable = {}
        if tmp ~= "" then
          oldmaptable = yajl.to_value(tmp)
        end

        local ok = loadMap(']]..filename..[[')
        if ok then
        local wc = mmp.lockWormholes()
	    local ws = mmp.lockSewers()
        mmp.lockPebble()
        if mmp.game == "achaea" and wc == 0 and ws == 0 then -- in achaea, using crowdmap, if we didn't get any special exits - it means Mudlet needs to be updated
          mmp.echo("Sorry, it seems your Mudlet isn't compatible with the new crowdmap format - and the map cannot be loaded fully. Please update your Mudlet:\n  http://www.mudlet.org/download/")
          return
        end

        if mmp.settings.waterwalk then mmp.enableWaterWalk() else mmp.disableWaterWalk() end

        mmp.echo("Map loaded successfully!")

          tmp = getRoomUserData(1, "gotoMapping")
          local newmaptable = {}
          if tmp ~= "" then
            newmaptable = yajl.to_value(tmp)
          end
          for k,v in pairs(oldmaptable) do newmaptable[k] = v end
          setRoomUserData(1, "gotoMapping", yajl.to_string(newmaptable))
          mmp.echo("Marks from the old map migrated successfully.")
          raiseEvent("mmapper updated map")
        else mmp.echo("Nope, didn't work. Open the map and try again?") end
      ]],
      "Click here to try loading the map again")
      echo(" to try loading it in again.\n")
    end

  elseif filename == tostring(mmp.downloadedscript) then   -- new mapper script xml downloaded
	mmp.checkingupdates = false

    mmp.echo("Your mapper script was downloaded to '"..filename.."' - uninstall the current copy and install the new one now!")

  elseif filename == tostring(mmp.mapfile) then   -- map version #, either IRE's or crowd
	mmp.checkingupdates = false

    local function needupdate(currentmd5, oldmd5)
      if not mmp.settings.crowdmap then
        mmp.echon("The games map was ")
        echoLink("updated", '', "New MD5: "..tostring(currentmd5)..", previous MD5: "..(oldmd5 or "(none)"), true)
        echo(" - you should update yours! Go to Settings -&gt; Mapper tab and click on the button there. Once you've updated, ")
        echoLink("click here", "mmp.updatedmap('"..currentmd5.."')", "Click here to quiet the update reminder")
        echo(" to remove the reminder.")
      else
        mmp.newversion, mmp.oldversion = currentmd5, oldmd5
        mmp.retrievecrowdchangelog()
      end
    end

    local f, s = io.open(filename)
    if f then s = f:read("*a"); io.close(f) end
    local currentmd5 = string.match(s, "([a-z0-9]+)  map%.xml")

    -- using crowdsourced map
    if not currentmd5 then
      currentmd5 = s:trim()
    end

	os.remove(filename)

    -- never checked yet?
    if not io.exists(getMudletHomeDir().."/map downloads/current") then needupdate(currentmd5) return end

    -- otherwise read old file and check
    local f, s = io.open(getMudletHomeDir().."/map downloads/current")
    if f then s = f:read("*a"); io.close(f) end

    if s ~= currentmd5 then needupdate(currentmd5, s) end
  end
end</script>
						<eventHandlerList>
							<string>sysDownloadDone</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>Check for updates</name>
						<packageName></packageName>
						<script>local downloadfolder = getMudletHomeDir() .. "/map downloads/"
local whereisit
-- this should get called at start and every hour after that

function mmp.checkforupdate()
  if not mmp.game or mmp.checkingupdates then
    return
  end
  local game = mmp.game
  mmp.mapfile = downloadfolder .. "MD5"
  mmp.mapperfile = downloadfolder .. "mapper"
  if not downloadFile then
    mmp.echo("Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+")
  else
    if not lfs.attributes(downloadfolder) then
      if lfs and lfs.mkdir then
        local t, s = lfs.mkdir(downloadfolder)
        if not t and s ~= "File exists" then
          mmp.echo("Couldn't make the '" .. downloadfolder .. "' folder; " .. s)
          return
        end
      else
        mmp.echo(
          "Sorry, but you need LuaFileSystem (lfs) installed, or have the '" ..
          downloadfolder ..
          "' folder exist."
        )
        return
      end
    end
    if mmp.settings.crowdmap then
      if game == "achaea" then
        downloadFile(
          mmp.mapfile, "http://ire-mudlet-mapping.github.io/AchaeaCrowdmap/Map/version.txt"
        )
      elseif game == "starmourn" then
        downloadFile(
          mmp.mapfile, "http://ire-mudlet-mapping.github.io/StarmournCrowdmap/Map/version.txt"
        )
      elseif game == "lusternia" then
        downloadFile(
          mmp.mapfile, "http://ire-mudlet-mapping.github.io/LusterniaCrowdmap/Map/version.txt"
        )
      end
    elseif mmp.settings.updatemap then
      downloadFile(mmp.mapfile, "http://www." .. game .. ".com/maps/MD5SUM")
    end
    downloadFile(
      mmp.mapperfile, "http://ire-mudlet-mapping.github.io/ire-mapping-script/downloads/version"
    )
    mmp.checkingupdates = true
  end
end

-- called by the user when the map is updated to register the fact that it was

function mmp.updatedmap(currentmd5)
  assert(currentmd5, "need md5 sum to write to file")
  local f, err = io.open(downloadfolder .. "current", "w")
  if not f then
    return mmp.echo("Couldn't write to the update file, because: " .. err)
  end
  f:write(currentmd5)
  f:close()
  local t = {"Go you for updating!", "Thanks for updating the map!", "Alright, map updated!"}
  mmp.echo(t[math.random(1, #t)])
end

-- downloads the latest changelog for the mapper if it was updated

function mmp.retrievechangelog()
  mmp.changelogfile = downloadfolder .. "changelog"
  downloadFile(
    mmp.changelogfile, "http://ire-mudlet-mapping.github.io/ire-mapping-script/downloads/changelog"
  )
end

function mmp.retrievecrowdchangelog()
  mmp.crowdchangelogfile = downloadfolder .. "crowdchangelogfile"
  if mmp.game == "achaea" then
    downloadFile(
      mmp.crowdchangelogfile, "http://ire-mudlet-mapping.github.io/AchaeaCrowdmap/Map/changelog.txt"
    )
  elseif mmp.game == "starmourn" then
    downloadFile(
      mmp.crowdchangelogfile,
      "http://ire-mudlet-mapping.github.io/StarmournCrowdmap/Map/changelog.txt"
    )
  elseif mmp.game == "lusternia" then
    downloadFile(
      mmp.crowdchangelogfile,
      "http://ire-mudlet-mapping.github.io/LusterniaCrowdmap/Map/changelog.txt"
    )
  end
end

-- downloads the public crowdsources map!

function mmp.downloadmapperscript()
  local downloadlocationfile = downloadfolder .. "savepath"
  local downloadlocation
  local exists = lfs.attributes
  -- somewhat complicated thing to nicely deal with all scenarios.
  if not exists(downloadlocationfile) then
    downloadlocation = whereisit()
    if not downloadlocation then
      return
    end
  end
  if not downloadlocation then
    local f, s = io.open(downloadlocationfile)
    if f then
      downloadlocation = f:read("*a");
      io.close(f)
    end
    if not exists(downloadlocation) then
      downloadlocation = whereisit()
      if not downloadlocation or not exists(downloadlocation) then
        return
      end
    end
  end
  mmp.downloadedscript = downloadlocation .. "/mudlet-mapper.xml"
  downloadFile(
    mmp.downloadedscript,
    "http://ire-mudlet-mapping.github.io/ire-mapping-script/downloads/mudlet-mapper.xml"
  )
  local f, err = io.open(downloadlocationfile, "w")
  if not f then
    return mmp.echo("Couldn't write to the location file, because: " .. err)
  end
  f:write(downloadlocation)
  f:close()
  mmp.echo("Okay, downloading the mapper script...")
end

function mmp.downloadcrowdmap(newversion)
  mmp.crowdmapfile = downloadfolder .. "crowdmap"
  local f, err = io.open(downloadfolder .. "current", "w")
  if not f then
    return mmp.echo("Couldn't write to the update file, because: " .. err)
  end
  f:write(newversion)
  f:close()
  if mmp.game == "achaea" then
    downloadFile(mmp.crowdmapfile, "http://ire-mudlet-mapping.github.io/AchaeaCrowdmap/Map/map")
  elseif mmp.game == "starmourn" then
    downloadFile(mmp.crowdmapfile, "http://ire-mudlet-mapping.github.io/StarmournCrowdmap/Map/map")
  elseif mmp.game == "lusternia" then
    downloadFile(mmp.crowdmapfile, "http://ire-mudlet-mapping.github.io/LusterniaCrowdmap/Map/map")
  end
  mmp.echo("Downloading the latest crowdmap...")
end

function mmp.showcrowdchangelog()
  mmp.echo("Public map changelog:")
  if not mmp.crowdchangelog then
    mmp.echo("(none yet)")
    return
  end
  for k, v in ipairs(mmp.crowdchangelog) do
    cecho(string.format("  %s) %s\n", k, v:gsub("\t", "     ")))
  end
end

whereisit =
  function()
    local path =
      invokeFileDialog(false, "Where should we save the file? Select a folder and click Open")
    if path == "" then
      return nil
    else
      return path
    end
  end</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>mmp_checkupdatestart</name>
							<packageName></packageName>
							<script>function mmp_checkupdatestart(...)
  if mmp.checkforupdatetimer then killTimer(mmp.checkforupdatetimer) end
  mmp.checkforupdatetimer = tempTimer(math.random(3, 10), mmp.checkforupdate)
end

function mmp.changeUpdateMap()
  if mmp.settings.updatemap then
    mmp.echo("Will check for new map updates from your MUD.")
    enableTimer"Check for updates periodically"
    mmp_checkupdatestart()
  else
    mmp.echo("Won't check for new map updates from your MUD.")
    disableTimer"Check for updates periodically"
	if mmp.checkforupdatetimer then killTimer("mmp.checkforupdatetimer") end
  end
end</script>
							<eventHandlerList>
								<string>mmp logged in</string>
							</eventHandlerList>
						</Script>
					</Script>
					<Script isActive="no" isFolder="no">
						<name>mmp_see_dl_errors</name>
						<packageName></packageName>
						<script>-- this should be off by default
function mmp_see_dl_errors(...)
  display{...}
end</script>
						<eventHandlerList>
							<string>sysDownloadError</string>
						</eventHandlerList>
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Initialize</name>
					<packageName></packageName>
					<script>mmp.startup()</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>mmp.mapdata_changed</name>
						<packageName></packageName>
						<script>-- aggregates map load and such events into one
function mmp.mapdata_changed()
  raiseEvent("mmapper map reloaded")
end
					</script>
						<eventHandlerList>
							<string>sysMapLoad</string>
							<string>sys2DMapLoad</string>
							<string>sys3DMapLoad</string>
							<string>sysMapDownloadEvent</string>
							<string>mapOpenEvent</string>
						</eventHandlerList>
					</Script>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>map features</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

local function loadMapFeatures()
  local mapFeaturesString = getMapUserData("mapFeatures")
  local mapFeatures
  if mapFeaturesString and mapFeaturesString ~= "" then
    mapFeatures = yajl.to_value(mapFeaturesString)
  else
    mapFeatures = {}
  end
  return mapFeatures
end

local function saveMapFeatures(mapFeaturesToSave)
  local mapFeaturesString = yajl.to_string(mapFeaturesToSave)
  setMapUserData("mapFeatures", mapFeaturesString)
end

function mmp.createMapFeature(featureName, roomCharacter)
  if not featureName or featureName == "" then
    mmp.echo("Can't create an empty map feature.")
    return
  end
  if featureName:find("%d") then
    mmp.echo("Map feature names must not contain numbers.")
    return
  end
  roomCharacter = roomCharacter or ""
  if type(roomCharacter) ~= "string" then
    mmp.echo(
      "The new room character must be either a string or nil. " ..
      type(roomCharacter) ..
      " is not allowed."
    )
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    mapFeatures[lowerFeatureName] = roomCharacter
    saveMapFeatures(mapFeatures)
    mmp.echo(
      "Created map feature '" ..
      featureName ..
      "' with the room character '" ..
      roomCharacter ..
      "'."
    )
  else
    mmp.echo("A map feature with the name '" .. featureName .. "' already exists.")
    return
  end
  return true
end

function mmp.listMapFeatures()
  local mapFeatures = loadMapFeatures()
  mmp.echo("This map has the following features:")
  echo(string.format("    %-25s | %s\n", "feature name", "room character"))
  echo(string.format("    %s\n", string.rep("-", 45)))
  for featureName, roomCharacter in pairs(mapFeatures) do
    echo(string.format("    %-25s | %s\n", featureName, roomCharacter))
  end
  return true
end

function mmp.roomCreateMapFeature(featureName, roomId)
  -- checks for the feature name
  if not featureName then
    mmp.echo("Which feature would you like to create?")
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    mmp.echo(
      "A feature with name '" ..
      featureName ..
      "' does not exist. You need to use 'feature create' first."
    )
    return
  end
  -- checks for the room ID
  if not roomId then
    if not mmp.currentroom then
      mmp.echo("Don't know where we are at the moment.")
      return
    end
    roomId = mmp.currentroom
  else
    if type(roomId) ~= "number" then
      mmp.echo("Need a room ID as number for creating a map feature on a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    mmp.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  -- check if feature already exists
  if table.contains(mmp.getRoomMapFeatures(roomId), lowerFeatureName) then
    mmp.echo("Room '" .. roomId .. "' has already map feature '" .. featureName .. "'.")
    return
  end
  -- create map feature in room
  setRoomUserData(roomId, "feature-" .. lowerFeatureName, "true")
  mmp.echo(string.format("Map feature '%s' created in room number '%d'.", featureName, roomId))
  local featureRoomChar = mapFeatures[lowerFeatureName]
  if featureRoomChar ~= "" then
    setRoomChar(roomId, featureRoomChar)
    mmp.echo("The room now carries the room char '" .. featureRoomChar .. "'.")
  end
  return true
end

function mmp.roomDeleteMapFeature(featureName, roomId)
  -- checks for the feature name
  if not featureName then
    mmp.echo("Which feature would you like to delete?")
    return
  end
  local lowerFeatureName = featureName:lower()
  -- checks for the room ID
  if not roomId then
    if not mmp.currentroom then
      mmp.echo("Don't know where we are at the moment.")
      return
    end
    roomId = mmp.currentroom
  else
    if type(roomId) ~= "number" then
      mmp.echo("Need a room ID as number for deleting a map feature from a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    mmp.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  -- check if feature exists
  local roomMapFeatures = mmp.getRoomMapFeatures(roomId)
  if not table.contains(roomMapFeatures, lowerFeatureName) then
    mmp.echo("Room '" .. roomId .. "' doesn't have map feature '" .. featureName .. "'.")
    return
  end
  -- delete map feature from room
  setRoomUserData(roomId, "feature-" .. lowerFeatureName, "")
  mmp.echo(string.format("Map feature '%s' deleted from room number '%d'.", featureName, roomId))
  -- now update room char if needed.
  -- first update current map features of this room
  roomMapFeatures = mmp.getRoomMapFeatures(roomId)
  local mapFeatures = loadMapFeatures()
  -- find out if we need to set a new room character
  if getRoomChar(roomId) == mapFeatures[lowerFeatureName] and getRoomChar(roomId) ~= "" then
    local index, otherRoomMapFeature
    -- find another usable room character
    repeat
      index, otherRoomMapFeature = next(roomMapFeatures, index)
    until not otherRoomMapFeature or mapFeatures[otherRoomMapFeature] ~= ""
    if otherRoomMapFeature then
      -- we found a usable room character, now set it
      local newRoomChar = mapFeatures[otherRoomMapFeature]
      setRoomChar(roomId, newRoomChar)
      mmp.echo("Using '" .. newRoomChar .. "' as new room character.")
    else
      -- we didn't find a usable room character, delete it.
      setRoomChar(roomId, "")
      mmp.echo("Deleted the current room character.")
    end
  end
  return true
end

function mmp.getRoomMapFeatures(roomId)
  -- checks for the room ID
  if not roomId then
    if not mmp.currentroom then
      mmp.echo("Don't know where we are at the moment.")
      return
    end
    roomId = mmp.currentroom
  else
    if type(roomId) ~= "number" then
      mmp.echo("Need a room ID as number for getting all map features of a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    mmp.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  local result = {}
  local mapFeatures = loadMapFeatures()
  for mapFeature in pairs(mapFeatures) do
    if getRoomUserData(roomId, "feature-" .. mapFeature) == "true" then
      result[#result + 1] = mapFeature
    end
  end
  return result
end

function mmp.deleteMapFeature(featureName)
  if not featureName or featureName == "" then
    mmp.echo("Which map feature would you like to delete?")
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    mmp.echo("Map feature '" .. featureName .. "' does not exist.")
    return
  end
  local roomsWithFeature = searchRoomUserData("feature-" .. lowerFeatureName, "true")
  for _, roomId in pairs(roomsWithFeature) do
    local deletionResult = mmp.roomDeleteMapFeature(lowerFeatureName, roomId)
    if not deletionResult then
      mmp.echo(
        "Something went wrong deleting the map feature '" ..
        featureName ..
        "' from all rooms. Deletion incomplete."
      )
      return
    end
  end
  mapFeatures[lowerFeatureName] = nil
  saveMapFeatures(mapFeatures)
  mmp.echo("Deleted map feature '" .. featureName .. "' from map.")
  return true
end

function mmp.getMapFeatures()
  return loadMapFeatures()
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Eot GUI On Install</name>
				<packageName></packageName>
				<script>function eotui.onInstall(_, package)
  if package:find("EOTUI") then
		info("Installing and loading system for the first time...")
		eotui.settingsLoad()
		echo("\n")
		info("Type 'eotui' to see a list of useful system help files.")
	end
end</script>
				<eventHandlerList>
					<string>sysInstall</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Eot GUI On Uninstall</name>
				<packageName></packageName>
				<script>-- This should work cleanly. If not, then just restart after uninstalling, everything should disappear.
function eotui.onUninstall(_, package)
  if package:find("EOTUI") then
    --Place all Containers here that need removed/destroyed
    
    
    eotui = nil
    
--Reset Borders (see if you can check against current borders)
    setBorderLeft(0)
    setBorderBottom(0)
    setBorderRight(0)
		moveCursorEnd("main") if getCurrentLine() ~= "" then echo"\n" end
    echo("End of Time UI has been uninstalled... Consider restarting your profile for a full clean of event handlers.\n")
  end
end</script>
				<eventHandlerList>
					<string>sysUninstall</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
